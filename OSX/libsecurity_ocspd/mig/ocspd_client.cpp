/*
 * IDENTIFICATION:
 * stub generated Mon Jul  3 19:46:36 2017
 * with a MiG generated by bootstrap_cmds-96.20.2
 * OPTIONS: 
 */
#define	__MIG_check__Reply__ocspd_subsystem__ 1

#include "ocspd.h"


#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__ocspdFetch_t__defined)
#define __MIG_check__Reply__ocspdFetch_t__defined

mig_internal kern_return_t __MIG_check__Reply__ocspdFetch_t(__Reply__ocspdFetch_t *Out0P)
{

	typedef __Reply__ocspdFetch_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 33103) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->ocsp_rep.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__ocspdFetch_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine ocspdFetch */
mig_external kern_return_t ocsp_client_ocspdFetch
(
	mach_port_t serverport,
	Data ocsp_req,
	mach_msg_type_number_t ocsp_reqCnt,
	Data *ocsp_rep,
	mach_msg_type_number_t *ocsp_repCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ocsp_req;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ocsp_reqCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ocsp_rep;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ocsp_repCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ocsp_rep;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ocsp_repCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__ocspdFetch_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__ocspdFetch_t__defined */

	__DeclareSendRpc(33003, "ocspdFetch")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t ocsp_reqTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->ocsp_req = ocsp_reqTemplate;
	InP->ocsp_req.address = (void *)(ocsp_req);
	InP->ocsp_req.size = ocsp_reqCnt;
#else	/* UseStaticTemplates */
	InP->ocsp_req.address = (void *)(ocsp_req);
	InP->ocsp_req.size = ocsp_reqCnt;
	InP->ocsp_req.deallocate =  FALSE;
	InP->ocsp_req.copy = MACH_MSG_VIRTUAL_COPY;
	InP->ocsp_req.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ocsp_reqCnt = ocsp_reqCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33003;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33003, "ocspdFetch")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33003, "ocspdFetch")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__ocspdFetch_t__defined)
	check_result = __MIG_check__Reply__ocspdFetch_t((__Reply__ocspdFetch_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__ocspdFetch_t__defined) */

	*ocsp_rep = (Data)(Out0P->ocsp_rep.address);
	*ocsp_repCnt = Out0P->ocsp_repCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__ocspdCacheFlush_t__defined)
#define __MIG_check__Reply__ocspdCacheFlush_t__defined

mig_internal kern_return_t __MIG_check__Reply__ocspdCacheFlush_t(__Reply__ocspdCacheFlush_t *Out0P)
{

	typedef __Reply__ocspdCacheFlush_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 33104) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__ocspdCacheFlush_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine ocspdCacheFlush */
mig_external kern_return_t ocsp_client_ocspdCacheFlush
(
	mach_port_t serverport,
	Data certID,
	mach_msg_type_number_t certIDCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t certID;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t certIDCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__ocspdCacheFlush_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__ocspdCacheFlush_t__defined */

	__DeclareSendRpc(33004, "ocspdCacheFlush")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t certIDTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->certID = certIDTemplate;
	InP->certID.address = (void *)(certID);
	InP->certID.size = certIDCnt;
#else	/* UseStaticTemplates */
	InP->certID.address = (void *)(certID);
	InP->certID.size = certIDCnt;
	InP->certID.deallocate =  FALSE;
	InP->certID.copy = MACH_MSG_VIRTUAL_COPY;
	InP->certID.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->certIDCnt = certIDCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33004;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33004, "ocspdCacheFlush")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33004, "ocspdCacheFlush")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__ocspdCacheFlush_t__defined)
	check_result = __MIG_check__Reply__ocspdCacheFlush_t((__Reply__ocspdCacheFlush_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__ocspdCacheFlush_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__ocspdCacheFlushStale_t__defined)
#define __MIG_check__Reply__ocspdCacheFlushStale_t__defined

mig_internal kern_return_t __MIG_check__Reply__ocspdCacheFlushStale_t(__Reply__ocspdCacheFlushStale_t *Out0P)
{

	typedef __Reply__ocspdCacheFlushStale_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 33105) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__ocspdCacheFlushStale_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine ocspdCacheFlushStale */
mig_external kern_return_t ocsp_client_ocspdCacheFlushStale
(
	mach_port_t serverport
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__ocspdCacheFlushStale_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__ocspdCacheFlushStale_t__defined */

	__DeclareSendRpc(33005, "ocspdCacheFlushStale")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33005;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33005, "ocspdCacheFlushStale")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33005, "ocspdCacheFlushStale")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__ocspdCacheFlushStale_t__defined)
	check_result = __MIG_check__Reply__ocspdCacheFlushStale_t((__Reply__ocspdCacheFlushStale_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__ocspdCacheFlushStale_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__certFetch_t__defined)
#define __MIG_check__Reply__certFetch_t__defined

mig_internal kern_return_t __MIG_check__Reply__certFetch_t(__Reply__certFetch_t *Out0P)
{

	typedef __Reply__certFetch_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 33106) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->cert_data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__certFetch_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine certFetch */
mig_external kern_return_t ocsp_client_certFetch
(
	mach_port_t serverport,
	Data cert_url,
	mach_msg_type_number_t cert_urlCnt,
	Data *cert_data,
	mach_msg_type_number_t *cert_dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cert_url;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t cert_urlCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cert_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t cert_dataCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cert_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t cert_dataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__certFetch_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__certFetch_t__defined */

	__DeclareSendRpc(33006, "certFetch")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t cert_urlTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->cert_url = cert_urlTemplate;
	InP->cert_url.address = (void *)(cert_url);
	InP->cert_url.size = cert_urlCnt;
#else	/* UseStaticTemplates */
	InP->cert_url.address = (void *)(cert_url);
	InP->cert_url.size = cert_urlCnt;
	InP->cert_url.deallocate =  FALSE;
	InP->cert_url.copy = MACH_MSG_VIRTUAL_COPY;
	InP->cert_url.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->cert_urlCnt = cert_urlCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33006;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33006, "certFetch")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33006, "certFetch")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__certFetch_t__defined)
	check_result = __MIG_check__Reply__certFetch_t((__Reply__certFetch_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__certFetch_t__defined) */

	*cert_data = (Data)(Out0P->cert_data.address);
	*cert_dataCnt = Out0P->cert_dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__crlFetch_t__defined)
#define __MIG_check__Reply__crlFetch_t__defined

mig_internal kern_return_t __MIG_check__Reply__crlFetch_t(__Reply__crlFetch_t *Out0P)
{

	typedef __Reply__crlFetch_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 33107) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->crl_data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__crlFetch_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine crlFetch */
mig_external kern_return_t ocsp_client_crlFetch
(
	mach_port_t serverport,
	Data crl_url,
	mach_msg_type_number_t crl_urlCnt,
	Data crl_issuer,
	mach_msg_type_number_t crl_issuerCnt,
	boolean_t cache_read,
	boolean_t cache_write,
	Data verify_time,
	mach_msg_type_number_t verify_timeCnt,
	Data *crl_data,
	mach_msg_type_number_t *crl_dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t crl_url;
		mach_msg_ool_descriptor_t crl_issuer;
		mach_msg_ool_descriptor_t verify_time;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t crl_urlCnt;
		mach_msg_type_number_t crl_issuerCnt;
		boolean_t cache_read;
		boolean_t cache_write;
		mach_msg_type_number_t verify_timeCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t crl_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t crl_dataCnt;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t crl_data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t crl_dataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__crlFetch_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__crlFetch_t__defined */

	__DeclareSendRpc(33007, "crlFetch")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t crl_urlTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t crl_issuerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t verify_timeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->crl_url = crl_urlTemplate;
	InP->crl_url.address = (void *)(crl_url);
	InP->crl_url.size = crl_urlCnt;
#else	/* UseStaticTemplates */
	InP->crl_url.address = (void *)(crl_url);
	InP->crl_url.size = crl_urlCnt;
	InP->crl_url.deallocate =  FALSE;
	InP->crl_url.copy = MACH_MSG_VIRTUAL_COPY;
	InP->crl_url.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->crl_issuer = crl_issuerTemplate;
	InP->crl_issuer.address = (void *)(crl_issuer);
	InP->crl_issuer.size = crl_issuerCnt;
#else	/* UseStaticTemplates */
	InP->crl_issuer.address = (void *)(crl_issuer);
	InP->crl_issuer.size = crl_issuerCnt;
	InP->crl_issuer.deallocate =  FALSE;
	InP->crl_issuer.copy = MACH_MSG_VIRTUAL_COPY;
	InP->crl_issuer.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->verify_time = verify_timeTemplate;
	InP->verify_time.address = (void *)(verify_time);
	InP->verify_time.size = verify_timeCnt;
#else	/* UseStaticTemplates */
	InP->verify_time.address = (void *)(verify_time);
	InP->verify_time.size = verify_timeCnt;
	InP->verify_time.deallocate =  FALSE;
	InP->verify_time.copy = MACH_MSG_VIRTUAL_COPY;
	InP->verify_time.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->crl_urlCnt = crl_urlCnt;

	InP->crl_issuerCnt = crl_issuerCnt;

	InP->cache_read = cache_read;

	InP->cache_write = cache_write;

	InP->verify_timeCnt = verify_timeCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33007;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33007, "crlFetch")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33007, "crlFetch")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__crlFetch_t__defined)
	check_result = __MIG_check__Reply__crlFetch_t((__Reply__crlFetch_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__crlFetch_t__defined) */

	*crl_data = (Data)(Out0P->crl_data.address);
	*crl_dataCnt = Out0P->crl_dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__crlRefresh_t__defined)
#define __MIG_check__Reply__crlRefresh_t__defined

mig_internal kern_return_t __MIG_check__Reply__crlRefresh_t(__Reply__crlRefresh_t *Out0P)
{

	typedef __Reply__crlRefresh_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 33108) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__crlRefresh_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine crlRefresh */
mig_external kern_return_t ocsp_client_crlRefresh
(
	mach_port_t serverport,
	uint32_t stale_days,
	uint32_t expire_overlap_seconds,
	boolean_t purge_all,
	boolean_t full_crypto_verify
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t stale_days;
		uint32_t expire_overlap_seconds;
		boolean_t purge_all;
		boolean_t full_crypto_verify;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__crlRefresh_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__crlRefresh_t__defined */

	__DeclareSendRpc(33008, "crlRefresh")

	InP->NDR = NDR_record;

	InP->stale_days = stale_days;

	InP->expire_overlap_seconds = expire_overlap_seconds;

	InP->purge_all = purge_all;

	InP->full_crypto_verify = full_crypto_verify;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33008;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33008, "crlRefresh")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33008, "crlRefresh")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__crlRefresh_t__defined)
	check_result = __MIG_check__Reply__crlRefresh_t((__Reply__crlRefresh_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__crlRefresh_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__crlFlush_t__defined)
#define __MIG_check__Reply__crlFlush_t__defined

mig_internal kern_return_t __MIG_check__Reply__crlFlush_t(__Reply__crlFlush_t *Out0P)
{

	typedef __Reply__crlFlush_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 33109) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__crlFlush_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine crlFlush */
mig_external kern_return_t ocsp_client_crlFlush
(
	mach_port_t serverport,
	Data cert_url,
	mach_msg_type_number_t cert_urlCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cert_url;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t cert_urlCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__crlFlush_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__crlFlush_t__defined */

	__DeclareSendRpc(33009, "crlFlush")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t cert_urlTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->cert_url = cert_urlTemplate;
	InP->cert_url.address = (void *)(cert_url);
	InP->cert_url.size = cert_urlCnt;
#else	/* UseStaticTemplates */
	InP->cert_url.address = (void *)(cert_url);
	InP->cert_url.size = cert_urlCnt;
	InP->cert_url.deallocate =  FALSE;
	InP->cert_url.copy = MACH_MSG_VIRTUAL_COPY;
	InP->cert_url.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->cert_urlCnt = cert_urlCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33009;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33009, "crlFlush")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33009, "crlFlush")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__crlFlush_t__defined)
	check_result = __MIG_check__Reply__crlFlush_t((__Reply__crlFlush_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__crlFlush_t__defined) */

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__trustSettingsRead_t__defined)
#define __MIG_check__Reply__trustSettingsRead_t__defined

mig_internal kern_return_t __MIG_check__Reply__trustSettingsRead_t(__Reply__trustSettingsRead_t *Out0P)
{

	typedef __Reply__trustSettingsRead_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 33110) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->trustSettings.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__trustSettingsRead_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine trustSettingsRead */
mig_external kern_return_t ocsp_client_trustSettingsRead
(
	mach_port_t serverport,
	uint32_t domain,
	Data *trustSettings,
	mach_msg_type_number_t *trustSettingsCnt,
	OSStatus *rcode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t domain;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t trustSettings;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t trustSettingsCnt;
		OSStatus rcode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t trustSettings;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t trustSettingsCnt;
		OSStatus rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__trustSettingsRead_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__trustSettingsRead_t__defined */

	__DeclareSendRpc(33010, "trustSettingsRead")

	InP->NDR = NDR_record;

	InP->domain = domain;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33010;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33010, "trustSettingsRead")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33010, "trustSettingsRead")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__trustSettingsRead_t__defined)
	check_result = __MIG_check__Reply__trustSettingsRead_t((__Reply__trustSettingsRead_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__trustSettingsRead_t__defined) */

	*trustSettings = (Data)(Out0P->trustSettings.address);
	*trustSettingsCnt = Out0P->trustSettingsCnt;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__trustSettingsWrite_t__defined)
#define __MIG_check__Reply__trustSettingsWrite_t__defined

mig_internal kern_return_t __MIG_check__Reply__trustSettingsWrite_t(__Reply__trustSettingsWrite_t *Out0P)
{

	typedef __Reply__trustSettingsWrite_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 33111) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__trustSettingsWrite_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine trustSettingsWrite */
mig_external kern_return_t ocsp_client_trustSettingsWrite
(
	mach_port_t serverport,
	mach_port_t clientport,
	uint32_t domain,
	Data authBlob,
	mach_msg_type_number_t authBlobCnt,
	Data trustSettings,
	mach_msg_type_number_t trustSettingsCnt,
	OSStatus *rcode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t clientport;
		mach_msg_ool_descriptor_t authBlob;
		mach_msg_ool_descriptor_t trustSettings;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t domain;
		mach_msg_type_number_t authBlobCnt;
		mach_msg_type_number_t trustSettingsCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		OSStatus rcode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		OSStatus rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__trustSettingsWrite_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__trustSettingsWrite_t__defined */

	__DeclareSendRpc(33011, "trustSettingsWrite")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t clientportTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t authBlobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t trustSettingsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->clientport = clientportTemplate;
	InP->clientport.name = clientport;
#else	/* UseStaticTemplates */
	InP->clientport.name = clientport;
	InP->clientport.disposition = 19;
	InP->clientport.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->authBlob = authBlobTemplate;
	InP->authBlob.address = (void *)(authBlob);
	InP->authBlob.size = authBlobCnt;
#else	/* UseStaticTemplates */
	InP->authBlob.address = (void *)(authBlob);
	InP->authBlob.size = authBlobCnt;
	InP->authBlob.deallocate =  FALSE;
	InP->authBlob.copy = MACH_MSG_VIRTUAL_COPY;
	InP->authBlob.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->trustSettings = trustSettingsTemplate;
	InP->trustSettings.address = (void *)(trustSettings);
	InP->trustSettings.size = trustSettingsCnt;
#else	/* UseStaticTemplates */
	InP->trustSettings.address = (void *)(trustSettings);
	InP->trustSettings.size = trustSettingsCnt;
	InP->trustSettings.deallocate =  FALSE;
	InP->trustSettings.copy = MACH_MSG_VIRTUAL_COPY;
	InP->trustSettings.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->domain = domain;

	InP->authBlobCnt = authBlobCnt;

	InP->trustSettingsCnt = trustSettingsCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33011;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33011, "trustSettingsWrite")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33011, "trustSettingsWrite")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__trustSettingsWrite_t__defined)
	check_result = __MIG_check__Reply__trustSettingsWrite_t((__Reply__trustSettingsWrite_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__trustSettingsWrite_t__defined) */

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ocspd_subsystem__
#if !defined(__MIG_check__Reply__crlStatus_t__defined)
#define __MIG_check__Reply__crlStatus_t__defined

mig_internal kern_return_t __MIG_check__Reply__crlStatus_t(__Reply__crlStatus_t *Out0P)
{

	typedef __Reply__crlStatus_t __Reply __attribute__((unused));
	if (Out0P->Head.msgh_id != 33112) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (Out0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Reply)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	{
		return Out0P->RetCode;
	}
}
#endif /* !defined(__MIG_check__Reply__crlStatus_t__defined) */
#endif /* __MIG_check__Reply__ocspd_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine crlStatus */
mig_external kern_return_t ocsp_client_crlStatus
(
	mach_port_t serverport,
	Data serial_number,
	mach_msg_type_number_t serial_numberCnt,
	Data cert_issuers,
	mach_msg_type_number_t cert_issuersCnt,
	Data crl_issuer,
	mach_msg_type_number_t crl_issuerCnt,
	Data crl_url,
	mach_msg_type_number_t crl_urlCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t serial_number;
		mach_msg_ool_descriptor_t cert_issuers;
		mach_msg_ool_descriptor_t crl_issuer;
		mach_msg_ool_descriptor_t crl_url;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t serial_numberCnt;
		mach_msg_type_number_t cert_issuersCnt;
		mach_msg_type_number_t crl_issuerCnt;
		mach_msg_type_number_t crl_urlCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__crlStatus_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__crlStatus_t__defined */

	__DeclareSendRpc(33012, "crlStatus")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t serial_numberTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t cert_issuersTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t crl_issuerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t crl_urlTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 4;
#if	UseStaticTemplates
	InP->serial_number = serial_numberTemplate;
	InP->serial_number.address = (void *)(serial_number);
	InP->serial_number.size = serial_numberCnt;
#else	/* UseStaticTemplates */
	InP->serial_number.address = (void *)(serial_number);
	InP->serial_number.size = serial_numberCnt;
	InP->serial_number.deallocate =  FALSE;
	InP->serial_number.copy = MACH_MSG_VIRTUAL_COPY;
	InP->serial_number.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->cert_issuers = cert_issuersTemplate;
	InP->cert_issuers.address = (void *)(cert_issuers);
	InP->cert_issuers.size = cert_issuersCnt;
#else	/* UseStaticTemplates */
	InP->cert_issuers.address = (void *)(cert_issuers);
	InP->cert_issuers.size = cert_issuersCnt;
	InP->cert_issuers.deallocate =  FALSE;
	InP->cert_issuers.copy = MACH_MSG_VIRTUAL_COPY;
	InP->cert_issuers.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->crl_issuer = crl_issuerTemplate;
	InP->crl_issuer.address = (void *)(crl_issuer);
	InP->crl_issuer.size = crl_issuerCnt;
#else	/* UseStaticTemplates */
	InP->crl_issuer.address = (void *)(crl_issuer);
	InP->crl_issuer.size = crl_issuerCnt;
	InP->crl_issuer.deallocate =  FALSE;
	InP->crl_issuer.copy = MACH_MSG_VIRTUAL_COPY;
	InP->crl_issuer.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->crl_url = crl_urlTemplate;
	InP->crl_url.address = (void *)(crl_url);
	InP->crl_url.size = crl_urlCnt;
#else	/* UseStaticTemplates */
	InP->crl_url.address = (void *)(crl_url);
	InP->crl_url.size = crl_urlCnt;
	InP->crl_url.deallocate =  FALSE;
	InP->crl_url.copy = MACH_MSG_VIRTUAL_COPY;
	InP->crl_url.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->serial_numberCnt = serial_numberCnt;

	InP->cert_issuersCnt = cert_issuersCnt;

	InP->crl_issuerCnt = crl_issuerCnt;

	InP->crl_urlCnt = crl_urlCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = serverport;
	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_id = 33012;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(33012, "crlStatus")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(33012, "crlStatus")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__crlStatus_t__defined)
	check_result = __MIG_check__Reply__crlStatus_t((__Reply__crlStatus_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__crlStatus_t__defined) */

	return KERN_SUCCESS;
}
