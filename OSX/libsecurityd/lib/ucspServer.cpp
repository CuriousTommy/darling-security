/*
 * IDENTIFICATION:
 * stub generated Mon Jul  3 19:46:45 2017
 * with a MiG generated by bootstrap_cmds-96.20.2
 * OPTIONS: 
 */

/* Module ucsp */

#define	__MIG_check__Request__ucsp_subsystem__ 1

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t *msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern int mig_strncpy_zerofill(char *dest, const char *src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <securityd_client/ss_types.h>
#include <securityd_client/ucsp_types.h>

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef	__DeclareRcvRpc
#define	__DeclareRcvRpc(_NUM_, _NAME_)
#endif	/* __DeclareRcvRpc */

#ifndef	__BeforeRcvRpc
#define	__BeforeRcvRpc(_NUM_, _NAME_)
#endif	/* __BeforeRcvRpc */

#ifndef	__AfterRcvRpc
#define	__AfterRcvRpc(_NUM_, _NAME_)
#endif	/* __AfterRcvRpc */

#ifndef	__DeclareRcvSimple
#define	__DeclareRcvSimple(_NUM_, _NAME_)
#endif	/* __DeclareRcvSimple */

#ifndef	__BeforeRcvSimple
#define	__BeforeRcvSimple(_NUM_, _NAME_)
#endif	/* __BeforeRcvSimple */

#ifndef	__AfterRcvSimple
#define	__AfterRcvSimple(_NUM_, _NAME_)
#endif	/* __AfterRcvSimple */

#define novalue void

#define msgh_request_port	msgh_local_port
#define MACH_MSGH_BITS_REQUEST(bits)	MACH_MSGH_BITS_LOCAL(bits)
#define msgh_reply_port		msgh_remote_port
#define MACH_MSGH_BITS_REPLY(bits)	MACH_MSGH_BITS_REMOTE(bits)

#define MIG_RETURN_ERROR(X, code)	{\
				((mig_reply_error_t *)X)->RetCode = code;\
				((mig_reply_error_t *)X)->NDR = NDR_record;\
				return;\
				}

/* typedefs for all requests */

#ifndef __Request__ucsp_subsystem__defined
#define __Request__ucsp_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		ClientSetupInfo info;
		mach_msg_type_number_t FilePathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t FilePathCnt;
		char FilePath[1024];
	} __Request__setup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
	} __Request__setupThread_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_ACCESS_TYPE accessType;
		mach_msg_type_number_t accessCredentialsCnt;
	} __Request__authenticateDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__releaseDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__getDbName_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
	} __Request__setDbName_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
		mach_msg_type_number_t accessCredentialsCnt;
	} __Request__openToken_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t query;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t queryCnt;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} __Request__findFirst_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCSearchHandle search;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} __Request__findNext_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCRecordHandle record;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} __Request__findRecordHandle_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		mach_msg_type_number_t dataCnt;
	} __Request__insertRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
	} __Request__deleteRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		boolean_t setData;
		mach_msg_type_number_t dataCnt;
		CSSM_DB_MODIFY_MODE modifyMode;
	} __Request__modifyRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCSearchHandle search;
	} __Request__releaseSearch_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCRecordHandle record;
	} __Request__releaseRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		DBParameters params;
	} __Request__createDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t blobCnt;
	} __Request__decodeDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__encodeDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		DBParameters params;
	} __Request__setDbParameters_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__getDbParameters_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t accessCredentialsCnt;
	} __Request__changePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t forSleep;
	} __Request__lockAll_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__unlockDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t passPhraseCnt;
	} __Request__unlockDbWithPassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__isLocked_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		boolean_t wantUid;
	} __Request__encodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t blobCnt;
	} __Request__decodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle oldDb;
		IPCKeyHandle key;
		IPCDbHandle newDb;
	} __Request__recodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} __Request__releaseKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} __Request__queryKeySizeInBits_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		uint32 inputSize;
		boolean_t encrypt;
	} __Request__getOutputSize_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} __Request__getKeyDigest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
	} __Request__generateSignature_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
	} __Request__verifySignature_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
	} __Request__generateMac_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
	} __Request__verifyMac_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t clearCnt;
	} __Request__encrypt_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t cipherCnt;
	} __Request__decrypt_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} __Request__generateKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 pubUsage;
		uint32 pubAttrs;
		uint32 privUsage;
		uint32 privAttrs;
	} __Request__generateKeyPair_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t descriptiveData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		IPCKeyHandle keyToBeWrapped;
		mach_msg_type_number_t descriptiveDataCnt;
	} __Request__wrapKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		IPCKeyHandle publicKey;
		mach_msg_type_number_t wrappedKeyCnt;
		uint32 usage;
		uint32 attributes;
	} __Request__unwrapKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t paramInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle baseKey;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		mach_msg_type_number_t paramInputCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} __Request__deriveKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t contextCnt;
	} __Request__generateRandom_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
	} __Request__getOwner_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclOwnerPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclOwnerPrototypeCnt;
	} __Request__setOwner_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		boolean_t haveTag;
		mach_msg_type_number_t tagOffset; /* MiG doesn't use it */
		mach_msg_type_number_t tagCnt;
		char tag[68];
	} __Request__getAcl_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		CSSM_ACL_EDIT_MODE mode;
		IPCGenericHandle handle;
		mach_msg_type_number_t aclEntryInputCnt;
	} __Request__changeAcl_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t name;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t nameCnt;
	} __Request__login_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__logout_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} __Request__getStatistics_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		CSSM_ALGORITHMS algorithm;
	} __Request__getTime_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} __Request__getCounter_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} __Request__selfVerify_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle hKey;
		mach_msg_type_number_t inDataCnt;
	} __Request__cspPassThrough_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t inDataCnt;
	} __Request__dlPassThrough_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 domain;
		uint32 event;
		mach_msg_type_number_t dataCnt;
		uint32 sequence;
	} __Request__postNotification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCDbHandle sourceDb;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} __Request__extractMasterKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t servicePort;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
	} __Request__childCheckIn_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		IPCDbHandle cloneDb;
	} __Request__commitDbForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 flags;
	} __Request__registerHosting_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		pid_t hostPid;
	} __Request__hostingPort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32 flags;
	} __Request__setGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef host;
		uint32_t status;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		mach_msg_type_number_t cdhashCnt;
		char cdhash[64];
		mach_msg_type_number_t attributesCnt;
		uint32 flags;
	} __Request__createGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32_t status;
		mach_msg_type_number_t attributesCnt;
	} __Request__setGuestStatus_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef host;
		SecGuestRef guest;
	} __Request__removeGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		uint32_t addType;
	} __Request__helpCheckLoad_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle dbToClone;
		IPCDbHandle srcDb;
	} __Request__recodeDbForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ipcDbHandleArray;
		mach_msg_ool_descriptor_t agentData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ipcDbHandleArrayCnt;
		mach_msg_type_number_t agentDataCnt;
	} __Request__authenticateDbsForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__verifyPrivileged_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__verifyPrivileged2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__stashDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__stashDbCheck_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t retries;
	} __Request__verifyKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t passPhraseCnt;
	} __Request__resetKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__changeKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 newVersion;
		IPCDbHandle srcDb;
	} __Request__recodeDbToVersion_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		mach_msg_type_number_t identCnt;
	} __Request__cloneDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} __Request__recodeFinished_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__getUserPromptAttempts_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__ucsp_subsystem__defined */

/* typedefs for all replies */

#ifndef __Reply__ucsp_subsystem__defined
#define __Reply__ucsp_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setupThread_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__authenticateDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__releaseDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
	} __Reply__getDbName_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setDbName_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply__openToken_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCSearchHandle search;
		IPCRecordHandle record;
	} __Reply__findFirst_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCRecordHandle record;
	} __Reply__findNext_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
	} __Reply__findRecordHandle_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
	} __Reply__insertRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__deleteRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
	} __Reply__modifyRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__releaseSearch_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__releaseRecord_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply__createDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply__decodeDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
	} __Reply__encodeDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setDbParameters_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		DBParameters params;
	} __Reply__getDbParameters_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__changePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__lockAll_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__unlockDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__unlockDbWithPassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		boolean_t locked;
	} __Reply__isLocked_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		mach_msg_ool_descriptor_t uid;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
		mach_msg_type_number_t uidCnt;
	} __Reply__encodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply__decodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t newBlob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t newBlobCnt;
	} __Reply__recodeKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__releaseKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_KEY_SIZE length;
	} __Reply__queryKeySizeInBits_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32 outputSize;
	} __Reply__getOutputSize_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t digest;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t digestCnt;
	} __Reply__getKeyDigest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
	} __Reply__generateSignature_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__verifySignature_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
	} __Reply__generateMac_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__verifyMac_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t cipherCnt;
	} __Reply__encrypt_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t clearCnt;
	} __Reply__decrypt_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply__generateKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t pubHeader;
		mach_msg_ool_descriptor_t privHeader;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle pubKey;
		mach_msg_type_number_t pubHeaderCnt;
		IPCKeyHandle privKey;
		mach_msg_type_number_t privHeaderCnt;
	} __Reply__generateKeyPair_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t wrappedKeyCnt;
	} __Reply__wrapKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle resultKey;
		mach_msg_type_number_t headerCnt;
	} __Reply__unwrapKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t paramOutput;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t paramOutputCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply__deriveKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply__generateRandom_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t proto;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t protoCnt;
	} __Reply__getOwner_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setOwner_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t acls;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		uint32 count;
		mach_msg_type_number_t aclsCnt;
	} __Reply__getAcl_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__changeAcl_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__login_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__logout_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_CSP_OPERATIONAL_STATISTICS statistics;
	} __Reply__getStatistics_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply__getTime_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply__getCounter_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__selfVerify_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
	} __Reply__cspPassThrough_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
	} __Reply__dlPassThrough_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__postNotification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply__extractMasterKey_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__childCheckIn_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
	} __Reply__commitDbForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__registerHosting_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
	} __Reply__hostingPort_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		SecGuestRef guest;
	} __Reply__createGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__setGuestStatus_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__removeGuest_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__helpCheckLoad_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply__recodeDbForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply__authenticateDbsForSync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__verifyPrivileged_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t originPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
	} __Reply__verifyPrivileged2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__stashDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__stashDbCheck_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__verifyKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__resetKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__changeKeyStorePassphrase_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply__recodeDbToVersion_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply__cloneDb_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply__recodeFinished_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32_t attempts;
	} __Reply__getUserPromptAttempts_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__ucsp_subsystem__defined */


/* union of all replies */

#ifndef __ReplyUnion__ucsp_server_ucsp_subsystem__defined
#define __ReplyUnion__ucsp_server_ucsp_subsystem__defined
union __ReplyUnion__ucsp_server_ucsp_subsystem {
	__Reply__setup_t Reply_setup;
	__Reply__setupThread_t Reply_setupThread;
	__Reply__authenticateDb_t Reply_authenticateDb;
	__Reply__releaseDb_t Reply_releaseDb;
	__Reply__getDbName_t Reply_getDbName;
	__Reply__setDbName_t Reply_setDbName;
	__Reply__openToken_t Reply_openToken;
	__Reply__findFirst_t Reply_findFirst;
	__Reply__findNext_t Reply_findNext;
	__Reply__findRecordHandle_t Reply_findRecordHandle;
	__Reply__insertRecord_t Reply_insertRecord;
	__Reply__deleteRecord_t Reply_deleteRecord;
	__Reply__modifyRecord_t Reply_modifyRecord;
	__Reply__releaseSearch_t Reply_releaseSearch;
	__Reply__releaseRecord_t Reply_releaseRecord;
	__Reply__createDb_t Reply_createDb;
	__Reply__decodeDb_t Reply_decodeDb;
	__Reply__encodeDb_t Reply_encodeDb;
	__Reply__setDbParameters_t Reply_setDbParameters;
	__Reply__getDbParameters_t Reply_getDbParameters;
	__Reply__changePassphrase_t Reply_changePassphrase;
	__Reply__lockAll_t Reply_lockAll;
	__Reply__unlockDb_t Reply_unlockDb;
	__Reply__unlockDbWithPassphrase_t Reply_unlockDbWithPassphrase;
	__Reply__isLocked_t Reply_isLocked;
	__Reply__encodeKey_t Reply_encodeKey;
	__Reply__decodeKey_t Reply_decodeKey;
	__Reply__recodeKey_t Reply_recodeKey;
	__Reply__releaseKey_t Reply_releaseKey;
	__Reply__queryKeySizeInBits_t Reply_queryKeySizeInBits;
	__Reply__getOutputSize_t Reply_getOutputSize;
	__Reply__getKeyDigest_t Reply_getKeyDigest;
	__Reply__generateSignature_t Reply_generateSignature;
	__Reply__verifySignature_t Reply_verifySignature;
	__Reply__generateMac_t Reply_generateMac;
	__Reply__verifyMac_t Reply_verifyMac;
	__Reply__encrypt_t Reply_encrypt;
	__Reply__decrypt_t Reply_decrypt;
	__Reply__generateKey_t Reply_generateKey;
	__Reply__generateKeyPair_t Reply_generateKeyPair;
	__Reply__wrapKey_t Reply_wrapKey;
	__Reply__unwrapKey_t Reply_unwrapKey;
	__Reply__deriveKey_t Reply_deriveKey;
	__Reply__generateRandom_t Reply_generateRandom;
	__Reply__getOwner_t Reply_getOwner;
	__Reply__setOwner_t Reply_setOwner;
	__Reply__getAcl_t Reply_getAcl;
	__Reply__changeAcl_t Reply_changeAcl;
	__Reply__login_t Reply_login;
	__Reply__logout_t Reply_logout;
	__Reply__getStatistics_t Reply_getStatistics;
	__Reply__getTime_t Reply_getTime;
	__Reply__getCounter_t Reply_getCounter;
	__Reply__selfVerify_t Reply_selfVerify;
	__Reply__cspPassThrough_t Reply_cspPassThrough;
	__Reply__dlPassThrough_t Reply_dlPassThrough;
	__Reply__postNotification_t Reply_postNotification;
	__Reply__extractMasterKey_t Reply_extractMasterKey;
	__Reply__childCheckIn_t Reply_childCheckIn;
	__Reply__commitDbForSync_t Reply_commitDbForSync;
	__Reply__registerHosting_t Reply_registerHosting;
	__Reply__hostingPort_t Reply_hostingPort;
	__Reply__setGuest_t Reply_setGuest;
	__Reply__createGuest_t Reply_createGuest;
	__Reply__setGuestStatus_t Reply_setGuestStatus;
	__Reply__removeGuest_t Reply_removeGuest;
	__Reply__helpCheckLoad_t Reply_helpCheckLoad;
	__Reply__recodeDbForSync_t Reply_recodeDbForSync;
	__Reply__authenticateDbsForSync_t Reply_authenticateDbsForSync;
	__Reply__verifyPrivileged_t Reply_verifyPrivileged;
	__Reply__verifyPrivileged2_t Reply_verifyPrivileged2;
	__Reply__stashDb_t Reply_stashDb;
	__Reply__stashDbCheck_t Reply_stashDbCheck;
	__Reply__verifyKeyStorePassphrase_t Reply_verifyKeyStorePassphrase;
	__Reply__resetKeyStorePassphrase_t Reply_resetKeyStorePassphrase;
	__Reply__changeKeyStorePassphrase_t Reply_changeKeyStorePassphrase;
	__Reply__recodeDbToVersion_t Reply_recodeDbToVersion;
	__Reply__cloneDb_t Reply_cloneDb;
	__Reply__recodeFinished_t Reply_recodeFinished;
	__Reply__getUserPromptAttempts_t Reply_getUserPromptAttempts;
};
#endif /* __RequestUnion__ucsp_server_ucsp_subsystem__defined */
/* Forward Declarations */


mig_internal novalue _Xsetup
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetupThread
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XauthenticateDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XreleaseDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetDbName
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetDbName
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XopenToken
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XfindFirst
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XfindNext
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XfindRecordHandle
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XinsertRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XdeleteRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XmodifyRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XreleaseSearch
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XreleaseRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XcreateDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XdecodeDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XencodeDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetDbParameters
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetDbParameters
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XchangePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XlockAll
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XunlockDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XunlockDbWithPassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XisLocked
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XencodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XdecodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XrecodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XreleaseKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XqueryKeySizeInBits
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetOutputSize
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetKeyDigest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgenerateSignature
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XverifySignature
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgenerateMac
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XverifyMac
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xencrypt
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xdecrypt
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgenerateKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgenerateKeyPair
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XwrapKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XunwrapKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XderiveKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgenerateRandom
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetOwner
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetOwner
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetAcl
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XchangeAcl
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xlogin
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xlogout
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetStatistics
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetTime
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetCounter
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XselfVerify
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XcspPassThrough
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XdlPassThrough
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XpostNotification
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XextractMasterKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XchildCheckIn
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XcommitDbForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XregisterHosting
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XhostingPort
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XcreateGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XsetGuestStatus
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XremoveGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XhelpCheckLoad
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XrecodeDbForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XauthenticateDbsForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XverifyPrivileged
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XverifyPrivileged2
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XstashDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XstashDbCheck
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XverifyKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XresetKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XchangeKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XrecodeDbToVersion
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XcloneDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XrecodeFinished
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _XgetUserPromptAttempts
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);


#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setup_t__defined)
#define __MIG_check__Request__setup_t__defined

mig_internal kern_return_t __MIG_check__Request__setup_t(__attribute__((__unused__)) __Request__setup_t *In0P)
{

	typedef __Request__setup_t __Request;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1024)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->tport.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->tport.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__setup_t__FilePathCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__setup_t__FilePathCnt(&In0P->FilePathCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__setup_t__FilePathCnt__defined */
#if	__MigTypeCheck
	if ( In0P->FilePathCnt > 1024 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1024)) < In0P->FilePathCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 1024) + _WALIGN_(In0P->FilePathCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->FilePath),  1024);
		if (( memchr(In0P->FilePath, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setup_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setup */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setup
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	mach_port_t tport,
	ClientSetupInfo info,
	FilePath FilePath
);

/* Routine setup */
mig_internal novalue _Xsetup
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		ClientSetupInfo info;
		mach_msg_type_number_t FilePathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t FilePathCnt;
		char FilePath[1024];
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setup_t __Request;
	typedef __Reply__setup_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setup_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setup_t__defined */

	__DeclareRcvRpc(1000, "setup")
	__BeforeRcvRpc(1000, "setup")

#if	defined(__MIG_check__Request__setup_t__defined)
	check_result = __MIG_check__Request__setup_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setup_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setup(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->tport.name, In0P->info, In0P->FilePath);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1000, "setup")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setupThread_t__defined)
#define __MIG_check__Request__setupThread_t__defined

mig_internal kern_return_t __MIG_check__Request__setupThread_t(__attribute__((__unused__)) __Request__setupThread_t *In0P)
{

	typedef __Request__setupThread_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->tport.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->tport.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setupThread_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setupThread */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setupThread
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	mach_port_t tport
);

/* Routine setupThread */
mig_internal novalue _XsetupThread
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setupThread_t __Request;
	typedef __Reply__setupThread_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setupThread_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setupThread_t__defined */

	__DeclareRcvRpc(1002, "setupThread")
	__BeforeRcvRpc(1002, "setupThread")

#if	defined(__MIG_check__Request__setupThread_t__defined)
	check_result = __MIG_check__Request__setupThread_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setupThread_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setupThread(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->tport.name);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1002, "setupThread")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__authenticateDb_t__defined)
#define __MIG_check__Request__authenticateDb_t__defined

mig_internal kern_return_t __MIG_check__Request__authenticateDb_t(__attribute__((__unused__)) __Request__authenticateDb_t *In0P)
{

	typedef __Request__authenticateDb_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__authenticateDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine authenticateDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_authenticateDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	CSSM_DB_ACCESS_TYPE accessType,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt
);

/* Routine authenticateDb */
mig_internal novalue _XauthenticateDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_ACCESS_TYPE accessType;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__authenticateDb_t __Request;
	typedef __Reply__authenticateDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__authenticateDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__authenticateDb_t__defined */

	__DeclareRcvRpc(1003, "authenticateDb")
	__BeforeRcvRpc(1003, "authenticateDb")

#if	defined(__MIG_check__Request__authenticateDb_t__defined)
	check_result = __MIG_check__Request__authenticateDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__authenticateDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_authenticateDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, In0P->accessType, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size);
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1003, "authenticateDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__releaseDb_t__defined)
#define __MIG_check__Request__releaseDb_t__defined

mig_internal kern_return_t __MIG_check__Request__releaseDb_t(__attribute__((__unused__)) __Request__releaseDb_t *In0P)
{

	typedef __Request__releaseDb_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__releaseDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_releaseDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db
);

/* Routine releaseDb */
mig_internal novalue _XreleaseDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__releaseDb_t __Request;
	typedef __Reply__releaseDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__releaseDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__releaseDb_t__defined */

	__DeclareRcvRpc(1004, "releaseDb")
	__BeforeRcvRpc(1004, "releaseDb")

#if	defined(__MIG_check__Request__releaseDb_t__defined)
	check_result = __MIG_check__Request__releaseDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__releaseDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_releaseDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1004, "releaseDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getDbName_t__defined)
#define __MIG_check__Request__getDbName_t__defined

mig_internal kern_return_t __MIG_check__Request__getDbName_t(__attribute__((__unused__)) __Request__getDbName_t *In0P)
{

	typedef __Request__getDbName_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getDbName_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getDbName */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getDbName
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	FilePathOut name
);

/* Routine getDbName */
mig_internal novalue _XgetDbName
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getDbName_t __Request;
	typedef __Reply__getDbName_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getDbName_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getDbName_t__defined */

	__DeclareRcvRpc(1005, "getDbName")
	__BeforeRcvRpc(1005, "getDbName")

#if	defined(__MIG_check__Request__getDbName_t__defined)
	check_result = __MIG_check__Request__getDbName_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getDbName_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_getDbName(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, OutP->name);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;

#ifdef __LP64__
	{
		size_t strLength = strlen(OutP->name) + 1;
		if (strLength > 0xffffffff)
			MIG_RETURN_ERROR(OutP, MIG_BAD_ARGUMENTS);
		OutP->nameCnt = (mach_msg_type_number_t) strLength;
	}
#else
	OutP->nameCnt = (mach_msg_type_number_t) strlen(OutP->name) + 1;
#endif /* __LP64__ */
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 1024) + (_WALIGN_((OutP->nameCnt + 3) & ~3));

	__AfterRcvRpc(1005, "getDbName")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setDbName_t__defined)
#define __MIG_check__Request__setDbName_t__defined

mig_internal kern_return_t __MIG_check__Request__setDbName_t(__attribute__((__unused__)) __Request__setDbName_t *In0P)
{

	typedef __Request__setDbName_t __Request;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1024)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__setDbName_t__nameCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__setDbName_t__nameCnt(&In0P->nameCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__setDbName_t__nameCnt__defined */
#if	__MigTypeCheck
	if ( In0P->nameCnt > 1024 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1024)) < In0P->nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 1024) + _WALIGN_(In0P->nameCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->name),  1024);
		if (( memchr(In0P->name, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setDbName_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setDbName */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setDbName
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	FilePath name
);

/* Routine setDbName */
mig_internal novalue _XsetDbName
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setDbName_t __Request;
	typedef __Reply__setDbName_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setDbName_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setDbName_t__defined */

	__DeclareRcvRpc(1006, "setDbName")
	__BeforeRcvRpc(1006, "setDbName")

#if	defined(__MIG_check__Request__setDbName_t__defined)
	check_result = __MIG_check__Request__setDbName_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setDbName_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setDbName(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, In0P->name);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1006, "setDbName")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__openToken_t__defined)
#define __MIG_check__Request__openToken_t__defined

mig_internal kern_return_t __MIG_check__Request__openToken_t(__attribute__((__unused__)) __Request__openToken_t *In0P, __attribute__((__unused__)) __Request__openToken_t **In1PP)
{

	typedef __Request__openToken_t __Request;
	__Request *In1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1024)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__openToken_t__nameCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__openToken_t__nameCnt(&In0P->nameCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__openToken_t__nameCnt__defined */
	msgh_size_delta = _WALIGN_(In0P->nameCnt);
#if	__MigTypeCheck
	if ( In0P->nameCnt > 1024 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1024)) < In0P->nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 1024) + _WALIGN_(In0P->nameCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 1024);

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In1P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->name),  1024);
		if (( memchr(In0P->name, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__openToken_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine openToken */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_openToken
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	FilePath name,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	IPCDbHandle *db
);

/* Routine openToken */
mig_internal novalue _XopenToken
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__openToken_t __Request;
	typedef __Reply__openToken_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Request *In1P;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__openToken_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__openToken_t__defined */

	__DeclareRcvRpc(1007, "openToken")
	__BeforeRcvRpc(1007, "openToken")

#if	defined(__MIG_check__Request__openToken_t__defined)
	check_result = __MIG_check__Request__openToken_t((__Request *)In0P, (__Request **)&In1P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__openToken_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_openToken(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, In0P->name, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, &OutP->db);
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1007, "openToken")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__findFirst_t__defined)
#define __MIG_check__Request__findFirst_t__defined

mig_internal kern_return_t __MIG_check__Request__findFirst_t(__attribute__((__unused__)) __Request__findFirst_t *In0P)
{

	typedef __Request__findFirst_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->query.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->inAttributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->query.size != In0P->queryCnt)
		return MIG_TYPE_ERROR;
	if (In0P->inAttributes.size != In0P->inAttributesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__findFirst_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findFirst */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_findFirst
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data query,
	mach_msg_type_number_t queryCnt,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key,
	IPCSearchHandle *search,
	IPCRecordHandle *record
);

/* Routine findFirst */
mig_internal novalue _XfindFirst
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t query;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t queryCnt;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__findFirst_t __Request;
	typedef __Reply__findFirst_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__findFirst_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__findFirst_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t outAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1008, "findFirst")
	__BeforeRcvRpc(1008, "findFirst")

#if	defined(__MIG_check__Request__findFirst_t__defined)
	check_result = __MIG_check__Request__findFirst_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__findFirst_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->outAttributes = outAttributesTemplate;
#else	/* UseStaticTemplates */
	OutP->outAttributes.deallocate =  FALSE;
	OutP->outAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->outAttributes.pad1 = 0;
	OutP->outAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->outAttributes.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->outAttributesCnt = 0;

	OutP->dataCnt = 0;

	RetCode = ucsp_server_findFirst(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->query.address), In0P->query.size, (Data)(In0P->inAttributes.address), In0P->inAttributes.size, (Data *)&(OutP->outAttributes.address), &OutP->outAttributesCnt, In0P->getData, (Data *)&(OutP->data.address), &OutP->dataCnt, &OutP->key, &OutP->search, &OutP->record);
	mig_deallocate((vm_offset_t) In0P->inAttributes.address, In0P->inAttributes.size);
	In0P->inAttributes.address = (void *) 0;
	In0P->inAttributes.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->query.address, In0P->query.size);
	In0P->query.address = (void *) 0;
	In0P->query.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->outAttributes.size = OutP->outAttributesCnt;

	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1008, "findFirst")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__findNext_t__defined)
#define __MIG_check__Request__findNext_t__defined

mig_internal kern_return_t __MIG_check__Request__findNext_t(__attribute__((__unused__)) __Request__findNext_t *In0P)
{

	typedef __Request__findNext_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->inAttributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->inAttributes.size != In0P->inAttributesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__findNext_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findNext */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_findNext
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCSearchHandle search,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key,
	IPCRecordHandle *record
);

/* Routine findNext */
mig_internal novalue _XfindNext
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCSearchHandle search;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__findNext_t __Request;
	typedef __Reply__findNext_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__findNext_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__findNext_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t outAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1009, "findNext")
	__BeforeRcvRpc(1009, "findNext")

#if	defined(__MIG_check__Request__findNext_t__defined)
	check_result = __MIG_check__Request__findNext_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__findNext_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->outAttributes = outAttributesTemplate;
#else	/* UseStaticTemplates */
	OutP->outAttributes.deallocate =  FALSE;
	OutP->outAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->outAttributes.pad1 = 0;
	OutP->outAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->outAttributes.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->outAttributesCnt = 0;

	OutP->dataCnt = 0;

	RetCode = ucsp_server_findNext(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->search, (Data)(In0P->inAttributes.address), In0P->inAttributes.size, (Data *)&(OutP->outAttributes.address), &OutP->outAttributesCnt, In0P->getData, (Data *)&(OutP->data.address), &OutP->dataCnt, &OutP->key, &OutP->record);
	mig_deallocate((vm_offset_t) In0P->inAttributes.address, In0P->inAttributes.size);
	In0P->inAttributes.address = (void *) 0;
	In0P->inAttributes.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->outAttributes.size = OutP->outAttributesCnt;

	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1009, "findNext")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__findRecordHandle_t__defined)
#define __MIG_check__Request__findRecordHandle_t__defined

mig_internal kern_return_t __MIG_check__Request__findRecordHandle_t(__attribute__((__unused__)) __Request__findRecordHandle_t *In0P)
{

	typedef __Request__findRecordHandle_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->inAttributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->inAttributes.size != In0P->inAttributesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__findRecordHandle_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findRecordHandle */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_findRecordHandle
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCRecordHandle record,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key
);

/* Routine findRecordHandle */
mig_internal novalue _XfindRecordHandle
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCRecordHandle record;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__findRecordHandle_t __Request;
	typedef __Reply__findRecordHandle_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__findRecordHandle_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__findRecordHandle_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t outAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1010, "findRecordHandle")
	__BeforeRcvRpc(1010, "findRecordHandle")

#if	defined(__MIG_check__Request__findRecordHandle_t__defined)
	check_result = __MIG_check__Request__findRecordHandle_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__findRecordHandle_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->outAttributes = outAttributesTemplate;
#else	/* UseStaticTemplates */
	OutP->outAttributes.deallocate =  FALSE;
	OutP->outAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->outAttributes.pad1 = 0;
	OutP->outAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->outAttributes.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->outAttributesCnt = 0;

	OutP->dataCnt = 0;

	RetCode = ucsp_server_findRecordHandle(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->record, (Data)(In0P->inAttributes.address), In0P->inAttributes.size, (Data *)&(OutP->outAttributes.address), &OutP->outAttributesCnt, In0P->getData, (Data *)&(OutP->data.address), &OutP->dataCnt, &OutP->key);
	mig_deallocate((vm_offset_t) In0P->inAttributes.address, In0P->inAttributes.size);
	In0P->inAttributes.address = (void *) 0;
	In0P->inAttributes.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->outAttributes.size = OutP->outAttributesCnt;

	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1010, "findRecordHandle")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__insertRecord_t__defined)
#define __MIG_check__Request__insertRecord_t__defined

mig_internal kern_return_t __MIG_check__Request__insertRecord_t(__attribute__((__unused__)) __Request__insertRecord_t *In0P)
{

	typedef __Request__insertRecord_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->attributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->attributes.size != In0P->attributesCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__insertRecord_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine insertRecord */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_insertRecord
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	CSSM_DB_RECORDTYPE recordType,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	Data data,
	mach_msg_type_number_t dataCnt,
	IPCRecordHandle *record
);

/* Routine insertRecord */
mig_internal novalue _XinsertRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__insertRecord_t __Request;
	typedef __Reply__insertRecord_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__insertRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__insertRecord_t__defined */

	__DeclareRcvRpc(1011, "insertRecord")
	__BeforeRcvRpc(1011, "insertRecord")

#if	defined(__MIG_check__Request__insertRecord_t__defined)
	check_result = __MIG_check__Request__insertRecord_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__insertRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_insertRecord(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, In0P->recordType, (Data)(In0P->attributes.address), In0P->attributes.size, (Data)(In0P->data.address), In0P->data.size, &OutP->record);
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->attributes.address, In0P->attributes.size);
	In0P->attributes.address = (void *) 0;
	In0P->attributes.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1011, "insertRecord")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__deleteRecord_t__defined)
#define __MIG_check__Request__deleteRecord_t__defined

mig_internal kern_return_t __MIG_check__Request__deleteRecord_t(__attribute__((__unused__)) __Request__deleteRecord_t *In0P)
{

	typedef __Request__deleteRecord_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__deleteRecord_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine deleteRecord */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_deleteRecord
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	IPCRecordHandle record
);

/* Routine deleteRecord */
mig_internal novalue _XdeleteRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__deleteRecord_t __Request;
	typedef __Reply__deleteRecord_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__deleteRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__deleteRecord_t__defined */

	__DeclareRcvRpc(1012, "deleteRecord")
	__BeforeRcvRpc(1012, "deleteRecord")

#if	defined(__MIG_check__Request__deleteRecord_t__defined)
	check_result = __MIG_check__Request__deleteRecord_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__deleteRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_deleteRecord(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, In0P->record);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1012, "deleteRecord")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__modifyRecord_t__defined)
#define __MIG_check__Request__modifyRecord_t__defined

mig_internal kern_return_t __MIG_check__Request__modifyRecord_t(__attribute__((__unused__)) __Request__modifyRecord_t *In0P)
{

	typedef __Request__modifyRecord_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->attributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->attributes.size != In0P->attributesCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__modifyRecord_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine modifyRecord */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_modifyRecord
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	IPCRecordHandle *record,
	CSSM_DB_RECORDTYPE recordType,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	boolean_t setData,
	Data data,
	mach_msg_type_number_t dataCnt,
	CSSM_DB_MODIFY_MODE modifyMode
);

/* Routine modifyRecord */
mig_internal novalue _XmodifyRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		boolean_t setData;
		mach_msg_type_number_t dataCnt;
		CSSM_DB_MODIFY_MODE modifyMode;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__modifyRecord_t __Request;
	typedef __Reply__modifyRecord_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__modifyRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__modifyRecord_t__defined */

	__DeclareRcvRpc(1013, "modifyRecord")
	__BeforeRcvRpc(1013, "modifyRecord")

#if	defined(__MIG_check__Request__modifyRecord_t__defined)
	check_result = __MIG_check__Request__modifyRecord_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__modifyRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_modifyRecord(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, &In0P->record, In0P->recordType, (Data)(In0P->attributes.address), In0P->attributes.size, In0P->setData, (Data)(In0P->data.address), In0P->data.size, In0P->modifyMode);
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->attributes.address, In0P->attributes.size);
	In0P->attributes.address = (void *) 0;
	In0P->attributes.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->record = In0P->record;

	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1013, "modifyRecord")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__releaseSearch_t__defined)
#define __MIG_check__Request__releaseSearch_t__defined

mig_internal kern_return_t __MIG_check__Request__releaseSearch_t(__attribute__((__unused__)) __Request__releaseSearch_t *In0P)
{

	typedef __Request__releaseSearch_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__releaseSearch_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseSearch */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_releaseSearch
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCSearchHandle search
);

/* Routine releaseSearch */
mig_internal novalue _XreleaseSearch
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCSearchHandle search;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__releaseSearch_t __Request;
	typedef __Reply__releaseSearch_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__releaseSearch_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__releaseSearch_t__defined */

	__DeclareRcvRpc(1014, "releaseSearch")
	__BeforeRcvRpc(1014, "releaseSearch")

#if	defined(__MIG_check__Request__releaseSearch_t__defined)
	check_result = __MIG_check__Request__releaseSearch_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__releaseSearch_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_releaseSearch(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->search);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1014, "releaseSearch")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__releaseRecord_t__defined)
#define __MIG_check__Request__releaseRecord_t__defined

mig_internal kern_return_t __MIG_check__Request__releaseRecord_t(__attribute__((__unused__)) __Request__releaseRecord_t *In0P)
{

	typedef __Request__releaseRecord_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__releaseRecord_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseRecord */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_releaseRecord
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCRecordHandle record
);

/* Routine releaseRecord */
mig_internal novalue _XreleaseRecord
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__releaseRecord_t __Request;
	typedef __Reply__releaseRecord_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__releaseRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__releaseRecord_t__defined */

	__DeclareRcvRpc(1015, "releaseRecord")
	__BeforeRcvRpc(1015, "releaseRecord")

#if	defined(__MIG_check__Request__releaseRecord_t__defined)
	check_result = __MIG_check__Request__releaseRecord_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__releaseRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_releaseRecord(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->record);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1015, "releaseRecord")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__createDb_t__defined)
#define __MIG_check__Request__createDb_t__defined

mig_internal kern_return_t __MIG_check__Request__createDb_t(__attribute__((__unused__)) __Request__createDb_t *In0P)
{

	typedef __Request__createDb_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->ident.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->ident.size != In0P->identCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__createDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine createDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_createDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle *db,
	Data ident,
	mach_msg_type_number_t identCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	DBParameters params
);

/* Routine createDb */
mig_internal novalue _XcreateDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		DBParameters params;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__createDb_t __Request;
	typedef __Reply__createDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__createDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__createDb_t__defined */

	__DeclareRcvRpc(1016, "createDb")
	__BeforeRcvRpc(1016, "createDb")

#if	defined(__MIG_check__Request__createDb_t__defined)
	check_result = __MIG_check__Request__createDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__createDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_createDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, &OutP->db, (Data)(In0P->ident.address), In0P->ident.size, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, In0P->params);
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->ident.address, In0P->ident.size);
	In0P->ident.address = (void *) 0;
	In0P->ident.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1016, "createDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__decodeDb_t__defined)
#define __MIG_check__Request__decodeDb_t__defined

mig_internal kern_return_t __MIG_check__Request__decodeDb_t(__attribute__((__unused__)) __Request__decodeDb_t *In0P)
{

	typedef __Request__decodeDb_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->ident.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->blob.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->ident.size != In0P->identCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->blob.size != In0P->blobCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__decodeDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decodeDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_decodeDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle *db,
	Data ident,
	mach_msg_type_number_t identCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Pointer blob,
	mach_msg_type_number_t blobCnt
);

/* Routine decodeDb */
mig_internal novalue _XdecodeDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t blobCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__decodeDb_t __Request;
	typedef __Reply__decodeDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__decodeDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__decodeDb_t__defined */

	__DeclareRcvRpc(1018, "decodeDb")
	__BeforeRcvRpc(1018, "decodeDb")

#if	defined(__MIG_check__Request__decodeDb_t__defined)
	check_result = __MIG_check__Request__decodeDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__decodeDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_decodeDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, &OutP->db, (Data)(In0P->ident.address), In0P->ident.size, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Pointer)(In0P->blob.address), In0P->blob.size);
	mig_deallocate((vm_offset_t) In0P->blob.address, In0P->blob.size);
	In0P->blob.address = (void *) 0;
	In0P->blob.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->ident.address, In0P->ident.size);
	In0P->ident.address = (void *) 0;
	In0P->ident.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1018, "decodeDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__encodeDb_t__defined)
#define __MIG_check__Request__encodeDb_t__defined

mig_internal kern_return_t __MIG_check__Request__encodeDb_t(__attribute__((__unused__)) __Request__encodeDb_t *In0P)
{

	typedef __Request__encodeDb_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__encodeDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encodeDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_encodeDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt
);

/* Routine encodeDb */
mig_internal novalue _XencodeDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__encodeDb_t __Request;
	typedef __Reply__encodeDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__encodeDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__encodeDb_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t blobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1019, "encodeDb")
	__BeforeRcvRpc(1019, "encodeDb")

#if	defined(__MIG_check__Request__encodeDb_t__defined)
	check_result = __MIG_check__Request__encodeDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__encodeDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->blob = blobTemplate;
#else	/* UseStaticTemplates */
	OutP->blob.deallocate =  FALSE;
	OutP->blob.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->blob.pad1 = 0;
	OutP->blob.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->blob.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->blobCnt = 0;

	RetCode = ucsp_server_encodeDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Pointer *)&(OutP->blob.address), &OutP->blobCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->blob.size = OutP->blobCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1019, "encodeDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setDbParameters_t__defined)
#define __MIG_check__Request__setDbParameters_t__defined

mig_internal kern_return_t __MIG_check__Request__setDbParameters_t(__attribute__((__unused__)) __Request__setDbParameters_t *In0P)
{

	typedef __Request__setDbParameters_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setDbParameters_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setDbParameters */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setDbParameters
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	DBParameters params
);

/* Routine setDbParameters */
mig_internal novalue _XsetDbParameters
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		DBParameters params;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setDbParameters_t __Request;
	typedef __Reply__setDbParameters_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setDbParameters_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setDbParameters_t__defined */

	__DeclareRcvRpc(1020, "setDbParameters")
	__BeforeRcvRpc(1020, "setDbParameters")

#if	defined(__MIG_check__Request__setDbParameters_t__defined)
	check_result = __MIG_check__Request__setDbParameters_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setDbParameters_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setDbParameters(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, In0P->params);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1020, "setDbParameters")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getDbParameters_t__defined)
#define __MIG_check__Request__getDbParameters_t__defined

mig_internal kern_return_t __MIG_check__Request__getDbParameters_t(__attribute__((__unused__)) __Request__getDbParameters_t *In0P)
{

	typedef __Request__getDbParameters_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getDbParameters_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getDbParameters */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getDbParameters
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	DBParameters *params
);

/* Routine getDbParameters */
mig_internal novalue _XgetDbParameters
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getDbParameters_t __Request;
	typedef __Reply__getDbParameters_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getDbParameters_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getDbParameters_t__defined */

	__DeclareRcvRpc(1021, "getDbParameters")
	__BeforeRcvRpc(1021, "getDbParameters")

#if	defined(__MIG_check__Request__getDbParameters_t__defined)
	check_result = __MIG_check__Request__getDbParameters_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getDbParameters_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_getDbParameters(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, &OutP->params);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1021, "getDbParameters")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__changePassphrase_t__defined)
#define __MIG_check__Request__changePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Request__changePassphrase_t(__attribute__((__unused__)) __Request__changePassphrase_t *In0P)
{

	typedef __Request__changePassphrase_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__changePassphrase_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changePassphrase */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_changePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt
);

/* Routine changePassphrase */
mig_internal novalue _XchangePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__changePassphrase_t __Request;
	typedef __Reply__changePassphrase_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__changePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__changePassphrase_t__defined */

	__DeclareRcvRpc(1022, "changePassphrase")
	__BeforeRcvRpc(1022, "changePassphrase")

#if	defined(__MIG_check__Request__changePassphrase_t__defined)
	check_result = __MIG_check__Request__changePassphrase_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__changePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_changePassphrase(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size);
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1022, "changePassphrase")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__lockAll_t__defined)
#define __MIG_check__Request__lockAll_t__defined

mig_internal kern_return_t __MIG_check__Request__lockAll_t(__attribute__((__unused__)) __Request__lockAll_t *In0P)
{

	typedef __Request__lockAll_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__lockAll_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine lockAll */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_lockAll
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	boolean_t forSleep
);

/* Routine lockAll */
mig_internal novalue _XlockAll
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t forSleep;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__lockAll_t __Request;
	typedef __Reply__lockAll_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__lockAll_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__lockAll_t__defined */

	__DeclareRcvRpc(1023, "lockAll")
	__BeforeRcvRpc(1023, "lockAll")

#if	defined(__MIG_check__Request__lockAll_t__defined)
	check_result = __MIG_check__Request__lockAll_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__lockAll_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_lockAll(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->forSleep);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1023, "lockAll")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__unlockDb_t__defined)
#define __MIG_check__Request__unlockDb_t__defined

mig_internal kern_return_t __MIG_check__Request__unlockDb_t(__attribute__((__unused__)) __Request__unlockDb_t *In0P)
{

	typedef __Request__unlockDb_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__unlockDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unlockDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_unlockDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db
);

/* Routine unlockDb */
mig_internal novalue _XunlockDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__unlockDb_t __Request;
	typedef __Reply__unlockDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__unlockDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__unlockDb_t__defined */

	__DeclareRcvRpc(1024, "unlockDb")
	__BeforeRcvRpc(1024, "unlockDb")

#if	defined(__MIG_check__Request__unlockDb_t__defined)
	check_result = __MIG_check__Request__unlockDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__unlockDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_unlockDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1024, "unlockDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__unlockDbWithPassphrase_t__defined)
#define __MIG_check__Request__unlockDbWithPassphrase_t__defined

mig_internal kern_return_t __MIG_check__Request__unlockDbWithPassphrase_t(__attribute__((__unused__)) __Request__unlockDbWithPassphrase_t *In0P)
{

	typedef __Request__unlockDbWithPassphrase_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->passPhrase.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->passPhrase.size != In0P->passPhraseCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__unlockDbWithPassphrase_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unlockDbWithPassphrase */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_unlockDbWithPassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data passPhrase,
	mach_msg_type_number_t passPhraseCnt
);

/* Routine unlockDbWithPassphrase */
mig_internal novalue _XunlockDbWithPassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t passPhraseCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__unlockDbWithPassphrase_t __Request;
	typedef __Reply__unlockDbWithPassphrase_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__unlockDbWithPassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__unlockDbWithPassphrase_t__defined */

	__DeclareRcvRpc(1025, "unlockDbWithPassphrase")
	__BeforeRcvRpc(1025, "unlockDbWithPassphrase")

#if	defined(__MIG_check__Request__unlockDbWithPassphrase_t__defined)
	check_result = __MIG_check__Request__unlockDbWithPassphrase_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__unlockDbWithPassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_unlockDbWithPassphrase(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->passPhrase.address), In0P->passPhrase.size);
	mig_deallocate((vm_offset_t) In0P->passPhrase.address, In0P->passPhrase.size);
	In0P->passPhrase.address = (void *) 0;
	In0P->passPhrase.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1025, "unlockDbWithPassphrase")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__isLocked_t__defined)
#define __MIG_check__Request__isLocked_t__defined

mig_internal kern_return_t __MIG_check__Request__isLocked_t(__attribute__((__unused__)) __Request__isLocked_t *In0P)
{

	typedef __Request__isLocked_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__isLocked_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine isLocked */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_isLocked
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	boolean_t *locked
);

/* Routine isLocked */
mig_internal novalue _XisLocked
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__isLocked_t __Request;
	typedef __Reply__isLocked_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__isLocked_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__isLocked_t__defined */

	__DeclareRcvRpc(1026, "isLocked")
	__BeforeRcvRpc(1026, "isLocked")

#if	defined(__MIG_check__Request__isLocked_t__defined)
	check_result = __MIG_check__Request__isLocked_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__isLocked_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_isLocked(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, &OutP->locked);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1026, "isLocked")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__encodeKey_t__defined)
#define __MIG_check__Request__encodeKey_t__defined

mig_internal kern_return_t __MIG_check__Request__encodeKey_t(__attribute__((__unused__)) __Request__encodeKey_t *In0P)
{

	typedef __Request__encodeKey_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__encodeKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encodeKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_encodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt,
	boolean_t wantUid,
	Data *uid,
	mach_msg_type_number_t *uidCnt
);

/* Routine encodeKey */
mig_internal novalue _XencodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		boolean_t wantUid;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__encodeKey_t __Request;
	typedef __Reply__encodeKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__encodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__encodeKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t blobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t uidTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1027, "encodeKey")
	__BeforeRcvRpc(1027, "encodeKey")

#if	defined(__MIG_check__Request__encodeKey_t__defined)
	check_result = __MIG_check__Request__encodeKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__encodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->blob = blobTemplate;
#else	/* UseStaticTemplates */
	OutP->blob.deallocate =  FALSE;
	OutP->blob.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->blob.pad1 = 0;
	OutP->blob.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->blob.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->uid = uidTemplate;
#else	/* UseStaticTemplates */
	OutP->uid.deallocate =  FALSE;
	OutP->uid.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->uid.pad1 = 0;
	OutP->uid.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->uid.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->blobCnt = 0;

	OutP->uidCnt = 0;

	RetCode = ucsp_server_encodeKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->key, (Pointer *)&(OutP->blob.address), &OutP->blobCnt, In0P->wantUid, (Data *)&(OutP->uid.address), &OutP->uidCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->blob.size = OutP->blobCnt;

	OutP->uid.size = OutP->uidCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1027, "encodeKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__decodeKey_t__defined)
#define __MIG_check__Request__decodeKey_t__defined

mig_internal kern_return_t __MIG_check__Request__decodeKey_t(__attribute__((__unused__)) __Request__decodeKey_t *In0P)
{

	typedef __Request__decodeKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->blob.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->blob.size != In0P->blobCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__decodeKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decodeKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_decodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt,
	IPCDbHandle db,
	Pointer blob,
	mach_msg_type_number_t blobCnt
);

/* Routine decodeKey */
mig_internal novalue _XdecodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t blobCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__decodeKey_t __Request;
	typedef __Reply__decodeKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__decodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__decodeKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t headerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1028, "decodeKey")
	__BeforeRcvRpc(1028, "decodeKey")

#if	defined(__MIG_check__Request__decodeKey_t__defined)
	check_result = __MIG_check__Request__decodeKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__decodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->header = headerTemplate;
#else	/* UseStaticTemplates */
	OutP->header.deallocate =  FALSE;
	OutP->header.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->header.pad1 = 0;
	OutP->header.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->header.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->headerCnt = 0;

	RetCode = ucsp_server_decodeKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, &OutP->key, (Data *)&(OutP->header.address), &OutP->headerCnt, In0P->db, (Pointer)(In0P->blob.address), In0P->blob.size);
	mig_deallocate((vm_offset_t) In0P->blob.address, In0P->blob.size);
	In0P->blob.address = (void *) 0;
	In0P->blob.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->header.size = OutP->headerCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1028, "decodeKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__recodeKey_t__defined)
#define __MIG_check__Request__recodeKey_t__defined

mig_internal kern_return_t __MIG_check__Request__recodeKey_t(__attribute__((__unused__)) __Request__recodeKey_t *In0P)
{

	typedef __Request__recodeKey_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__recodeKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_recodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle oldDb,
	IPCKeyHandle key,
	IPCDbHandle newDb,
	Pointer *newBlob,
	mach_msg_type_number_t *newBlobCnt
);

/* Routine recodeKey */
mig_internal novalue _XrecodeKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle oldDb;
		IPCKeyHandle key;
		IPCDbHandle newDb;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__recodeKey_t __Request;
	typedef __Reply__recodeKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__recodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__recodeKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t newBlobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1029, "recodeKey")
	__BeforeRcvRpc(1029, "recodeKey")

#if	defined(__MIG_check__Request__recodeKey_t__defined)
	check_result = __MIG_check__Request__recodeKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__recodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->newBlob = newBlobTemplate;
#else	/* UseStaticTemplates */
	OutP->newBlob.deallocate =  FALSE;
	OutP->newBlob.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->newBlob.pad1 = 0;
	OutP->newBlob.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->newBlob.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->newBlobCnt = 0;

	RetCode = ucsp_server_recodeKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->oldDb, In0P->key, In0P->newDb, (Pointer *)&(OutP->newBlob.address), &OutP->newBlobCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->newBlob.size = OutP->newBlobCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1029, "recodeKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__releaseKey_t__defined)
#define __MIG_check__Request__releaseKey_t__defined

mig_internal kern_return_t __MIG_check__Request__releaseKey_t(__attribute__((__unused__)) __Request__releaseKey_t *In0P)
{

	typedef __Request__releaseKey_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__releaseKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_releaseKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCKeyHandle key
);

/* Routine releaseKey */
mig_internal novalue _XreleaseKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__releaseKey_t __Request;
	typedef __Reply__releaseKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__releaseKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__releaseKey_t__defined */

	__DeclareRcvRpc(1030, "releaseKey")
	__BeforeRcvRpc(1030, "releaseKey")

#if	defined(__MIG_check__Request__releaseKey_t__defined)
	check_result = __MIG_check__Request__releaseKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__releaseKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_releaseKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->key);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1030, "releaseKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__queryKeySizeInBits_t__defined)
#define __MIG_check__Request__queryKeySizeInBits_t__defined

mig_internal kern_return_t __MIG_check__Request__queryKeySizeInBits_t(__attribute__((__unused__)) __Request__queryKeySizeInBits_t *In0P)
{

	typedef __Request__queryKeySizeInBits_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__queryKeySizeInBits_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine queryKeySizeInBits */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_queryKeySizeInBits
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	CSSM_KEY_SIZE *length
);

/* Routine queryKeySizeInBits */
mig_internal novalue _XqueryKeySizeInBits
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__queryKeySizeInBits_t __Request;
	typedef __Reply__queryKeySizeInBits_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__queryKeySizeInBits_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__queryKeySizeInBits_t__defined */

	__DeclareRcvRpc(1031, "queryKeySizeInBits")
	__BeforeRcvRpc(1031, "queryKeySizeInBits")

#if	defined(__MIG_check__Request__queryKeySizeInBits_t__defined)
	check_result = __MIG_check__Request__queryKeySizeInBits_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__queryKeySizeInBits_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_queryKeySizeInBits(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->key, &OutP->length);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1031, "queryKeySizeInBits")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getOutputSize_t__defined)
#define __MIG_check__Request__getOutputSize_t__defined

mig_internal kern_return_t __MIG_check__Request__getOutputSize_t(__attribute__((__unused__)) __Request__getOutputSize_t *In0P)
{

	typedef __Request__getOutputSize_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getOutputSize_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getOutputSize */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getOutputSize
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	uint32 inputSize,
	boolean_t encrypt,
	uint32 *outputSize
);

/* Routine getOutputSize */
mig_internal novalue _XgetOutputSize
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		uint32 inputSize;
		boolean_t encrypt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getOutputSize_t __Request;
	typedef __Reply__getOutputSize_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getOutputSize_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getOutputSize_t__defined */

	__DeclareRcvRpc(1032, "getOutputSize")
	__BeforeRcvRpc(1032, "getOutputSize")

#if	defined(__MIG_check__Request__getOutputSize_t__defined)
	check_result = __MIG_check__Request__getOutputSize_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getOutputSize_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_getOutputSize(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, In0P->inputSize, In0P->encrypt, &OutP->outputSize);
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1032, "getOutputSize")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getKeyDigest_t__defined)
#define __MIG_check__Request__getKeyDigest_t__defined

mig_internal kern_return_t __MIG_check__Request__getKeyDigest_t(__attribute__((__unused__)) __Request__getKeyDigest_t *In0P)
{

	typedef __Request__getKeyDigest_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getKeyDigest_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getKeyDigest */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getKeyDigest
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	Data *digest,
	mach_msg_type_number_t *digestCnt
);

/* Routine getKeyDigest */
mig_internal novalue _XgetKeyDigest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getKeyDigest_t __Request;
	typedef __Reply__getKeyDigest_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getKeyDigest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getKeyDigest_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t digestTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1033, "getKeyDigest")
	__BeforeRcvRpc(1033, "getKeyDigest")

#if	defined(__MIG_check__Request__getKeyDigest_t__defined)
	check_result = __MIG_check__Request__getKeyDigest_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getKeyDigest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->digest = digestTemplate;
#else	/* UseStaticTemplates */
	OutP->digest.deallocate =  FALSE;
	OutP->digest.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->digest.pad1 = 0;
	OutP->digest.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->digest.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->digestCnt = 0;

	RetCode = ucsp_server_getKeyDigest(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->key, (Data *)&(OutP->digest.address), &OutP->digestCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->digest.size = OutP->digestCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1033, "getKeyDigest")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__generateSignature_t__defined)
#define __MIG_check__Request__generateSignature_t__defined

mig_internal kern_return_t __MIG_check__Request__generateSignature_t(__attribute__((__unused__)) __Request__generateSignature_t *In0P)
{

	typedef __Request__generateSignature_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__generateSignature_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateSignature */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_generateSignature
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	CSSM_ALGORITHMS signOnlyAlgorithm,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data *signature,
	mach_msg_type_number_t *signatureCnt
);

/* Routine generateSignature */
mig_internal novalue _XgenerateSignature
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__generateSignature_t __Request;
	typedef __Reply__generateSignature_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__generateSignature_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__generateSignature_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t signatureTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1034, "generateSignature")
	__BeforeRcvRpc(1034, "generateSignature")

#if	defined(__MIG_check__Request__generateSignature_t__defined)
	check_result = __MIG_check__Request__generateSignature_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__generateSignature_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->signature = signatureTemplate;
#else	/* UseStaticTemplates */
	OutP->signature.deallocate =  FALSE;
	OutP->signature.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->signature.pad1 = 0;
	OutP->signature.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->signature.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->signatureCnt = 0;

	RetCode = ucsp_server_generateSignature(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, In0P->signOnlyAlgorithm, (Data)(In0P->data.address), In0P->data.size, (Data *)&(OutP->signature.address), &OutP->signatureCnt);
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->signature.size = OutP->signatureCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1034, "generateSignature")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__verifySignature_t__defined)
#define __MIG_check__Request__verifySignature_t__defined

mig_internal kern_return_t __MIG_check__Request__verifySignature_t(__attribute__((__unused__)) __Request__verifySignature_t *In0P)
{

	typedef __Request__verifySignature_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->signature.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
	if (In0P->signature.size != In0P->signatureCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__verifySignature_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifySignature */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_verifySignature
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	CSSM_ALGORITHMS signOnlyAlgorithm,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data signature,
	mach_msg_type_number_t signatureCnt
);

/* Routine verifySignature */
mig_internal novalue _XverifySignature
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__verifySignature_t __Request;
	typedef __Reply__verifySignature_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__verifySignature_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__verifySignature_t__defined */

	__DeclareRcvRpc(1035, "verifySignature")
	__BeforeRcvRpc(1035, "verifySignature")

#if	defined(__MIG_check__Request__verifySignature_t__defined)
	check_result = __MIG_check__Request__verifySignature_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__verifySignature_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_verifySignature(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, In0P->signOnlyAlgorithm, (Data)(In0P->data.address), In0P->data.size, (Data)(In0P->signature.address), In0P->signature.size);
	mig_deallocate((vm_offset_t) In0P->signature.address, In0P->signature.size);
	In0P->signature.address = (void *) 0;
	In0P->signature.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1035, "verifySignature")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__generateMac_t__defined)
#define __MIG_check__Request__generateMac_t__defined

mig_internal kern_return_t __MIG_check__Request__generateMac_t(__attribute__((__unused__)) __Request__generateMac_t *In0P)
{

	typedef __Request__generateMac_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__generateMac_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateMac */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_generateMac
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data *signature,
	mach_msg_type_number_t *signatureCnt
);

/* Routine generateMac */
mig_internal novalue _XgenerateMac
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__generateMac_t __Request;
	typedef __Reply__generateMac_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__generateMac_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__generateMac_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t signatureTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1036, "generateMac")
	__BeforeRcvRpc(1036, "generateMac")

#if	defined(__MIG_check__Request__generateMac_t__defined)
	check_result = __MIG_check__Request__generateMac_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__generateMac_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->signature = signatureTemplate;
#else	/* UseStaticTemplates */
	OutP->signature.deallocate =  FALSE;
	OutP->signature.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->signature.pad1 = 0;
	OutP->signature.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->signature.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->signatureCnt = 0;

	RetCode = ucsp_server_generateMac(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->data.address), In0P->data.size, (Data *)&(OutP->signature.address), &OutP->signatureCnt);
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->signature.size = OutP->signatureCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1036, "generateMac")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__verifyMac_t__defined)
#define __MIG_check__Request__verifyMac_t__defined

mig_internal kern_return_t __MIG_check__Request__verifyMac_t(__attribute__((__unused__)) __Request__verifyMac_t *In0P)
{

	typedef __Request__verifyMac_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->signature.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
	if (In0P->signature.size != In0P->signatureCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__verifyMac_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyMac */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_verifyMac
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data signature,
	mach_msg_type_number_t signatureCnt
);

/* Routine verifyMac */
mig_internal novalue _XverifyMac
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__verifyMac_t __Request;
	typedef __Reply__verifyMac_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__verifyMac_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__verifyMac_t__defined */

	__DeclareRcvRpc(1037, "verifyMac")
	__BeforeRcvRpc(1037, "verifyMac")

#if	defined(__MIG_check__Request__verifyMac_t__defined)
	check_result = __MIG_check__Request__verifyMac_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__verifyMac_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_verifyMac(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->data.address), In0P->data.size, (Data)(In0P->signature.address), In0P->signature.size);
	mig_deallocate((vm_offset_t) In0P->signature.address, In0P->signature.size);
	In0P->signature.address = (void *) 0;
	In0P->signature.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1037, "verifyMac")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__encrypt_t__defined)
#define __MIG_check__Request__encrypt_t__defined

mig_internal kern_return_t __MIG_check__Request__encrypt_t(__attribute__((__unused__)) __Request__encrypt_t *In0P)
{

	typedef __Request__encrypt_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->clear.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->clear.size != In0P->clearCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__encrypt_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encrypt */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_encrypt
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data clear,
	mach_msg_type_number_t clearCnt,
	Data *cipher,
	mach_msg_type_number_t *cipherCnt
);

/* Routine encrypt */
mig_internal novalue _Xencrypt
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t clearCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__encrypt_t __Request;
	typedef __Reply__encrypt_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__encrypt_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__encrypt_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t cipherTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1038, "encrypt")
	__BeforeRcvRpc(1038, "encrypt")

#if	defined(__MIG_check__Request__encrypt_t__defined)
	check_result = __MIG_check__Request__encrypt_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__encrypt_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->cipher = cipherTemplate;
#else	/* UseStaticTemplates */
	OutP->cipher.deallocate =  FALSE;
	OutP->cipher.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->cipher.pad1 = 0;
	OutP->cipher.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->cipher.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->cipherCnt = 0;

	RetCode = ucsp_server_encrypt(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->clear.address), In0P->clear.size, (Data *)&(OutP->cipher.address), &OutP->cipherCnt);
	mig_deallocate((vm_offset_t) In0P->clear.address, In0P->clear.size);
	In0P->clear.address = (void *) 0;
	In0P->clear.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->cipher.size = OutP->cipherCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1038, "encrypt")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__decrypt_t__defined)
#define __MIG_check__Request__decrypt_t__defined

mig_internal kern_return_t __MIG_check__Request__decrypt_t(__attribute__((__unused__)) __Request__decrypt_t *In0P)
{

	typedef __Request__decrypt_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->cipher.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->cipher.size != In0P->cipherCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__decrypt_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decrypt */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_decrypt
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data cipher,
	mach_msg_type_number_t cipherCnt,
	Data *clear,
	mach_msg_type_number_t *clearCnt
);

/* Routine decrypt */
mig_internal novalue _Xdecrypt
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t cipherCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__decrypt_t __Request;
	typedef __Reply__decrypt_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__decrypt_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__decrypt_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t clearTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1039, "decrypt")
	__BeforeRcvRpc(1039, "decrypt")

#if	defined(__MIG_check__Request__decrypt_t__defined)
	check_result = __MIG_check__Request__decrypt_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__decrypt_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->clear = clearTemplate;
#else	/* UseStaticTemplates */
	OutP->clear.deallocate =  FALSE;
	OutP->clear.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->clear.pad1 = 0;
	OutP->clear.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->clear.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->clearCnt = 0;

	RetCode = ucsp_server_decrypt(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->cipher.address), In0P->cipher.size, (Data *)&(OutP->clear.address), &OutP->clearCnt);
	mig_deallocate((vm_offset_t) In0P->cipher.address, In0P->cipher.size);
	In0P->cipher.address = (void *) 0;
	In0P->cipher.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->clear.size = OutP->clearCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1039, "decrypt")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__generateKey_t__defined)
#define __MIG_check__Request__generateKey_t__defined

mig_internal kern_return_t __MIG_check__Request__generateKey_t(__attribute__((__unused__)) __Request__generateKey_t *In0P)
{

	typedef __Request__generateKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__generateKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_generateKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
);

/* Routine generateKey */
mig_internal novalue _XgenerateKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__generateKey_t __Request;
	typedef __Reply__generateKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__generateKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__generateKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t headerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1040, "generateKey")
	__BeforeRcvRpc(1040, "generateKey")

#if	defined(__MIG_check__Request__generateKey_t__defined)
	check_result = __MIG_check__Request__generateKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__generateKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->header = headerTemplate;
#else	/* UseStaticTemplates */
	OutP->header.deallocate =  FALSE;
	OutP->header.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->header.pad1 = 0;
	OutP->header.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->header.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->headerCnt = 0;

	RetCode = ucsp_server_generateKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->context.address), In0P->context.size, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, In0P->keyUsage, In0P->keyAttrs, &OutP->key, (Data *)&(OutP->header.address), &OutP->headerCnt);
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->header.size = OutP->headerCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1040, "generateKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__generateKeyPair_t__defined)
#define __MIG_check__Request__generateKeyPair_t__defined

mig_internal kern_return_t __MIG_check__Request__generateKeyPair_t(__attribute__((__unused__)) __Request__generateKeyPair_t *In0P)
{

	typedef __Request__generateKeyPair_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__generateKeyPair_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateKeyPair */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_generateKeyPair
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 pubUsage,
	uint32 pubAttrs,
	uint32 privUsage,
	uint32 privAttrs,
	IPCKeyHandle *pubKey,
	Data *pubHeader,
	mach_msg_type_number_t *pubHeaderCnt,
	IPCKeyHandle *privKey,
	Data *privHeader,
	mach_msg_type_number_t *privHeaderCnt
);

/* Routine generateKeyPair */
mig_internal novalue _XgenerateKeyPair
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 pubUsage;
		uint32 pubAttrs;
		uint32 privUsage;
		uint32 privAttrs;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__generateKeyPair_t __Request;
	typedef __Reply__generateKeyPair_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__generateKeyPair_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__generateKeyPair_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t pubHeaderTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t privHeaderTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1041, "generateKeyPair")
	__BeforeRcvRpc(1041, "generateKeyPair")

#if	defined(__MIG_check__Request__generateKeyPair_t__defined)
	check_result = __MIG_check__Request__generateKeyPair_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__generateKeyPair_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->pubHeader = pubHeaderTemplate;
#else	/* UseStaticTemplates */
	OutP->pubHeader.deallocate =  FALSE;
	OutP->pubHeader.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->pubHeader.pad1 = 0;
	OutP->pubHeader.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->pubHeader.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->privHeader = privHeaderTemplate;
#else	/* UseStaticTemplates */
	OutP->privHeader.deallocate =  FALSE;
	OutP->privHeader.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->privHeader.pad1 = 0;
	OutP->privHeader.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->privHeader.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->pubHeaderCnt = 0;

	OutP->privHeaderCnt = 0;

	RetCode = ucsp_server_generateKeyPair(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->context.address), In0P->context.size, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, In0P->pubUsage, In0P->pubAttrs, In0P->privUsage, In0P->privAttrs, &OutP->pubKey, (Data *)&(OutP->pubHeader.address), &OutP->pubHeaderCnt, &OutP->privKey, (Data *)&(OutP->privHeader.address), &OutP->privHeaderCnt);
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->pubHeader.size = OutP->pubHeaderCnt;

	OutP->privHeader.size = OutP->privHeaderCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1041, "generateKeyPair")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__wrapKey_t__defined)
#define __MIG_check__Request__wrapKey_t__defined

mig_internal kern_return_t __MIG_check__Request__wrapKey_t(__attribute__((__unused__)) __Request__wrapKey_t *In0P)
{

	typedef __Request__wrapKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->descriptiveData.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->descriptiveData.size != In0P->descriptiveDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__wrapKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine wrapKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_wrapKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	IPCKeyHandle keyToBeWrapped,
	Data descriptiveData,
	mach_msg_type_number_t descriptiveDataCnt,
	Data *wrappedKey,
	mach_msg_type_number_t *wrappedKeyCnt
);

/* Routine wrapKey */
mig_internal novalue _XwrapKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t descriptiveData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		IPCKeyHandle keyToBeWrapped;
		mach_msg_type_number_t descriptiveDataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__wrapKey_t __Request;
	typedef __Reply__wrapKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__wrapKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__wrapKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t wrappedKeyTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1042, "wrapKey")
	__BeforeRcvRpc(1042, "wrapKey")

#if	defined(__MIG_check__Request__wrapKey_t__defined)
	check_result = __MIG_check__Request__wrapKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__wrapKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->wrappedKey = wrappedKeyTemplate;
#else	/* UseStaticTemplates */
	OutP->wrappedKey.deallocate =  FALSE;
	OutP->wrappedKey.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->wrappedKey.pad1 = 0;
	OutP->wrappedKey.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->wrappedKey.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->wrappedKeyCnt = 0;

	RetCode = ucsp_server_wrapKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, In0P->keyToBeWrapped, (Data)(In0P->descriptiveData.address), In0P->descriptiveData.size, (Data *)&(OutP->wrappedKey.address), &OutP->wrappedKeyCnt);
	mig_deallocate((vm_offset_t) In0P->descriptiveData.address, In0P->descriptiveData.size);
	In0P->descriptiveData.address = (void *) 0;
	In0P->descriptiveData.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->wrappedKey.size = OutP->wrappedKeyCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1042, "wrapKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__unwrapKey_t__defined)
#define __MIG_check__Request__unwrapKey_t__defined

mig_internal kern_return_t __MIG_check__Request__unwrapKey_t(__attribute__((__unused__)) __Request__unwrapKey_t *In0P)
{

	typedef __Request__unwrapKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 4) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->wrappedKey.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
	if (In0P->wrappedKey.size != In0P->wrappedKeyCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__unwrapKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unwrapKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_unwrapKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	IPCKeyHandle publicKey,
	Data wrappedKey,
	mach_msg_type_number_t wrappedKeyCnt,
	uint32 usage,
	uint32 attributes,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *resultKey,
	Data *header,
	mach_msg_type_number_t *headerCnt
);

/* Routine unwrapKey */
mig_internal novalue _XunwrapKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		IPCKeyHandle publicKey;
		mach_msg_type_number_t wrappedKeyCnt;
		uint32 usage;
		uint32 attributes;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__unwrapKey_t __Request;
	typedef __Reply__unwrapKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__unwrapKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__unwrapKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t headerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1043, "unwrapKey")
	__BeforeRcvRpc(1043, "unwrapKey")

#if	defined(__MIG_check__Request__unwrapKey_t__defined)
	check_result = __MIG_check__Request__unwrapKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__unwrapKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->header = headerTemplate;
#else	/* UseStaticTemplates */
	OutP->header.deallocate =  FALSE;
	OutP->header.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->header.pad1 = 0;
	OutP->header.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->header.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->dataCnt = 0;

	OutP->headerCnt = 0;

	RetCode = ucsp_server_unwrapKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->context.address), In0P->context.size, In0P->key, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, In0P->publicKey, (Data)(In0P->wrappedKey.address), In0P->wrappedKey.size, In0P->usage, In0P->attributes, (Data *)&(OutP->data.address), &OutP->dataCnt, &OutP->resultKey, (Data *)&(OutP->header.address), &OutP->headerCnt);
	mig_deallocate((vm_offset_t) In0P->wrappedKey.address, In0P->wrappedKey.size);
	In0P->wrappedKey.address = (void *) 0;
	In0P->wrappedKey.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->data.size = OutP->dataCnt;

	OutP->header.size = OutP->headerCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1043, "unwrapKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__deriveKey_t__defined)
#define __MIG_check__Request__deriveKey_t__defined

mig_internal kern_return_t __MIG_check__Request__deriveKey_t(__attribute__((__unused__)) __Request__deriveKey_t *In0P)
{

	typedef __Request__deriveKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 4) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->paramInput.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
	if (In0P->paramInput.size != In0P->paramInputCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__deriveKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine deriveKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_deriveKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle baseKey,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	Data paramInput,
	mach_msg_type_number_t paramInputCnt,
	Data *paramOutput,
	mach_msg_type_number_t *paramOutputCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
);

/* Routine deriveKey */
mig_internal novalue _XderiveKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t paramInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle baseKey;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		mach_msg_type_number_t paramInputCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__deriveKey_t __Request;
	typedef __Reply__deriveKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__deriveKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__deriveKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t paramOutputTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t headerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1044, "deriveKey")
	__BeforeRcvRpc(1044, "deriveKey")

#if	defined(__MIG_check__Request__deriveKey_t__defined)
	check_result = __MIG_check__Request__deriveKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__deriveKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->paramOutput = paramOutputTemplate;
#else	/* UseStaticTemplates */
	OutP->paramOutput.deallocate =  FALSE;
	OutP->paramOutput.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->paramOutput.pad1 = 0;
	OutP->paramOutput.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->paramOutput.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


#if	UseStaticTemplates
	OutP->header = headerTemplate;
#else	/* UseStaticTemplates */
	OutP->header.deallocate =  FALSE;
	OutP->header.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->header.pad1 = 0;
	OutP->header.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->header.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->paramOutputCnt = 0;

	OutP->headerCnt = 0;

	RetCode = ucsp_server_deriveKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->context.address), In0P->context.size, In0P->baseKey, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, (Data)(In0P->paramInput.address), In0P->paramInput.size, (Data *)&(OutP->paramOutput.address), &OutP->paramOutputCnt, In0P->keyUsage, In0P->keyAttrs, &OutP->key, (Data *)&(OutP->header.address), &OutP->headerCnt);
	mig_deallocate((vm_offset_t) In0P->paramInput.address, In0P->paramInput.size);
	In0P->paramInput.address = (void *) 0;
	In0P->paramInput.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->paramOutput.size = OutP->paramOutputCnt;

	OutP->header.size = OutP->headerCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 2;
	__AfterRcvRpc(1044, "deriveKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__generateRandom_t__defined)
#define __MIG_check__Request__generateRandom_t__defined

mig_internal kern_return_t __MIG_check__Request__generateRandom_t(__attribute__((__unused__)) __Request__generateRandom_t *In0P)
{

	typedef __Request__generateRandom_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__generateRandom_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateRandom */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_generateRandom
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data *data,
	mach_msg_type_number_t *dataCnt
);

/* Routine generateRandom */
mig_internal novalue _XgenerateRandom
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t contextCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__generateRandom_t __Request;
	typedef __Reply__generateRandom_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__generateRandom_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__generateRandom_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1045, "generateRandom")
	__BeforeRcvRpc(1045, "generateRandom")

#if	defined(__MIG_check__Request__generateRandom_t__defined)
	check_result = __MIG_check__Request__generateRandom_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__generateRandom_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->dataCnt = 0;

	RetCode = ucsp_server_generateRandom(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, (Data)(In0P->context.address), In0P->context.size, (Data *)&(OutP->data.address), &OutP->dataCnt);
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1045, "generateRandom")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getOwner_t__defined)
#define __MIG_check__Request__getOwner_t__defined

mig_internal kern_return_t __MIG_check__Request__getOwner_t(__attribute__((__unused__)) __Request__getOwner_t *In0P)
{

	typedef __Request__getOwner_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getOwner_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getOwner */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getOwner
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data *proto,
	mach_msg_type_number_t *protoCnt
);

/* Routine getOwner */
mig_internal novalue _XgetOwner
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getOwner_t __Request;
	typedef __Reply__getOwner_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getOwner_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getOwner_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t protoTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1046, "getOwner")
	__BeforeRcvRpc(1046, "getOwner")

#if	defined(__MIG_check__Request__getOwner_t__defined)
	check_result = __MIG_check__Request__getOwner_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getOwner_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->proto = protoTemplate;
#else	/* UseStaticTemplates */
	OutP->proto.deallocate =  FALSE;
	OutP->proto.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->proto.pad1 = 0;
	OutP->proto.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->proto.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->protoCnt = 0;

	RetCode = ucsp_server_getOwner(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->kind, In0P->key, (Data *)&(OutP->proto.address), &OutP->protoCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->proto.size = OutP->protoCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1046, "getOwner")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setOwner_t__defined)
#define __MIG_check__Request__setOwner_t__defined

mig_internal kern_return_t __MIG_check__Request__setOwner_t(__attribute__((__unused__)) __Request__setOwner_t *In0P)
{

	typedef __Request__setOwner_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclOwnerPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclOwnerPrototype.size != In0P->aclOwnerPrototypeCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setOwner_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setOwner */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setOwner
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclOwnerPrototype,
	mach_msg_type_number_t aclOwnerPrototypeCnt
);

/* Routine setOwner */
mig_internal novalue _XsetOwner
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclOwnerPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclOwnerPrototypeCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setOwner_t __Request;
	typedef __Reply__setOwner_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setOwner_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setOwner_t__defined */

	__DeclareRcvRpc(1047, "setOwner")
	__BeforeRcvRpc(1047, "setOwner")

#if	defined(__MIG_check__Request__setOwner_t__defined)
	check_result = __MIG_check__Request__setOwner_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setOwner_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setOwner(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->kind, In0P->key, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclOwnerPrototype.address), In0P->aclOwnerPrototype.size);
	mig_deallocate((vm_offset_t) In0P->aclOwnerPrototype.address, In0P->aclOwnerPrototype.size);
	In0P->aclOwnerPrototype.address = (void *) 0;
	In0P->aclOwnerPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1047, "setOwner")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getAcl_t__defined)
#define __MIG_check__Request__getAcl_t__defined

mig_internal kern_return_t __MIG_check__Request__getAcl_t(__attribute__((__unused__)) __Request__getAcl_t *In0P)
{

	typedef __Request__getAcl_t __Request;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 68)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__getAcl_t__tagCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__getAcl_t__tagCnt(&In0P->tagCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__getAcl_t__tagCnt__defined */
#if	__MigTypeCheck
	if ( In0P->tagCnt > 68 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 68)) < In0P->tagCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 68) + _WALIGN_(In0P->tagCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->tag),  68);
		if (( memchr(In0P->tag, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getAcl_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getAcl */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getAcl
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	boolean_t haveTag,
	CssmString tag,
	uint32 *count,
	Data *acls,
	mach_msg_type_number_t *aclsCnt
);

/* Routine getAcl */
mig_internal novalue _XgetAcl
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		boolean_t haveTag;
		mach_msg_type_number_t tagOffset; /* MiG doesn't use it */
		mach_msg_type_number_t tagCnt;
		char tag[68];
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getAcl_t __Request;
	typedef __Reply__getAcl_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getAcl_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getAcl_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1048, "getAcl")
	__BeforeRcvRpc(1048, "getAcl")

#if	defined(__MIG_check__Request__getAcl_t__defined)
	check_result = __MIG_check__Request__getAcl_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getAcl_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->acls = aclsTemplate;
#else	/* UseStaticTemplates */
	OutP->acls.deallocate =  FALSE;
	OutP->acls.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->acls.pad1 = 0;
	OutP->acls.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->acls.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->aclsCnt = 0;

	RetCode = ucsp_server_getAcl(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->kind, In0P->key, In0P->haveTag, In0P->tag, &OutP->count, (Data *)&(OutP->acls.address), &OutP->aclsCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->acls.size = OutP->aclsCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1048, "getAcl")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__changeAcl_t__defined)
#define __MIG_check__Request__changeAcl_t__defined

mig_internal kern_return_t __MIG_check__Request__changeAcl_t(__attribute__((__unused__)) __Request__changeAcl_t *In0P)
{

	typedef __Request__changeAcl_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryInput.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryInput.size != In0P->aclEntryInputCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__changeAcl_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changeAcl */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_changeAcl
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	CSSM_ACL_EDIT_MODE mode,
	IPCGenericHandle handle,
	Data aclEntryInput,
	mach_msg_type_number_t aclEntryInputCnt
);

/* Routine changeAcl */
mig_internal novalue _XchangeAcl
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		CSSM_ACL_EDIT_MODE mode;
		IPCGenericHandle handle;
		mach_msg_type_number_t aclEntryInputCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__changeAcl_t __Request;
	typedef __Reply__changeAcl_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__changeAcl_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__changeAcl_t__defined */

	__DeclareRcvRpc(1049, "changeAcl")
	__BeforeRcvRpc(1049, "changeAcl")

#if	defined(__MIG_check__Request__changeAcl_t__defined)
	check_result = __MIG_check__Request__changeAcl_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__changeAcl_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_changeAcl(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->kind, In0P->key, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, In0P->mode, In0P->handle, (Data)(In0P->aclEntryInput.address), In0P->aclEntryInput.size);
	mig_deallocate((vm_offset_t) In0P->aclEntryInput.address, In0P->aclEntryInput.size);
	In0P->aclEntryInput.address = (void *) 0;
	In0P->aclEntryInput.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1049, "changeAcl")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__login_t__defined)
#define __MIG_check__Request__login_t__defined

mig_internal kern_return_t __MIG_check__Request__login_t(__attribute__((__unused__)) __Request__login_t *In0P)
{

	typedef __Request__login_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->name.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->name.size != In0P->nameCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__login_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine login */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_login
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data name,
	mach_msg_type_number_t nameCnt
);

/* Routine login */
mig_internal novalue _Xlogin
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t name;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t nameCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__login_t __Request;
	typedef __Reply__login_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__login_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__login_t__defined */

	__DeclareRcvRpc(1050, "login")
	__BeforeRcvRpc(1050, "login")

#if	defined(__MIG_check__Request__login_t__defined)
	check_result = __MIG_check__Request__login_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__login_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_login(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->name.address), In0P->name.size);
	mig_deallocate((vm_offset_t) In0P->name.address, In0P->name.size);
	In0P->name.address = (void *) 0;
	In0P->name.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1050, "login")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__logout_t__defined)
#define __MIG_check__Request__logout_t__defined

mig_internal kern_return_t __MIG_check__Request__logout_t(__attribute__((__unused__)) __Request__logout_t *In0P)
{

	typedef __Request__logout_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__logout_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine logout */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_logout
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode
);

/* Routine logout */
mig_internal novalue _Xlogout
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__logout_t __Request;
	typedef __Reply__logout_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__logout_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__logout_t__defined */

	__DeclareRcvRpc(1051, "logout")
	__BeforeRcvRpc(1051, "logout")

#if	defined(__MIG_check__Request__logout_t__defined)
	check_result = __MIG_check__Request__logout_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__logout_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_logout(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1051, "logout")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getStatistics_t__defined)
#define __MIG_check__Request__getStatistics_t__defined

mig_internal kern_return_t __MIG_check__Request__getStatistics_t(__attribute__((__unused__)) __Request__getStatistics_t *In0P)
{

	typedef __Request__getStatistics_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getStatistics_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getStatistics */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getStatistics
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	CSSM_CSP_OPERATIONAL_STATISTICS *statistics
);

/* Routine getStatistics */
mig_internal novalue _XgetStatistics
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getStatistics_t __Request;
	typedef __Reply__getStatistics_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getStatistics_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getStatistics_t__defined */

	__DeclareRcvRpc(1052, "getStatistics")
	__BeforeRcvRpc(1052, "getStatistics")

#if	defined(__MIG_check__Request__getStatistics_t__defined)
	check_result = __MIG_check__Request__getStatistics_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getStatistics_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_getStatistics(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, &OutP->statistics);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1052, "getStatistics")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getTime_t__defined)
#define __MIG_check__Request__getTime_t__defined

mig_internal kern_return_t __MIG_check__Request__getTime_t(__attribute__((__unused__)) __Request__getTime_t *In0P)
{

	typedef __Request__getTime_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getTime_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getTime */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getTime
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	CSSM_ALGORITHMS algorithm,
	Data *data,
	mach_msg_type_number_t *dataCnt
);

/* Routine getTime */
mig_internal novalue _XgetTime
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		CSSM_ALGORITHMS algorithm;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getTime_t __Request;
	typedef __Reply__getTime_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getTime_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getTime_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1053, "getTime")
	__BeforeRcvRpc(1053, "getTime")

#if	defined(__MIG_check__Request__getTime_t__defined)
	check_result = __MIG_check__Request__getTime_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getTime_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->dataCnt = 0;

	RetCode = ucsp_server_getTime(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, In0P->algorithm, (Data *)&(OutP->data.address), &OutP->dataCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1053, "getTime")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getCounter_t__defined)
#define __MIG_check__Request__getCounter_t__defined

mig_internal kern_return_t __MIG_check__Request__getCounter_t(__attribute__((__unused__)) __Request__getCounter_t *In0P)
{

	typedef __Request__getCounter_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getCounter_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getCounter */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getCounter
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	Data *data,
	mach_msg_type_number_t *dataCnt
);

/* Routine getCounter */
mig_internal novalue _XgetCounter
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getCounter_t __Request;
	typedef __Reply__getCounter_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getCounter_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getCounter_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1054, "getCounter")
	__BeforeRcvRpc(1054, "getCounter")

#if	defined(__MIG_check__Request__getCounter_t__defined)
	check_result = __MIG_check__Request__getCounter_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getCounter_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->data = dataTemplate;
#else	/* UseStaticTemplates */
	OutP->data.deallocate =  FALSE;
	OutP->data.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->data.pad1 = 0;
	OutP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->data.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->dataCnt = 0;

	RetCode = ucsp_server_getCounter(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, (Data *)&(OutP->data.address), &OutP->dataCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->data.size = OutP->dataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1054, "getCounter")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__selfVerify_t__defined)
#define __MIG_check__Request__selfVerify_t__defined

mig_internal kern_return_t __MIG_check__Request__selfVerify_t(__attribute__((__unused__)) __Request__selfVerify_t *In0P)
{

	typedef __Request__selfVerify_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__selfVerify_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine selfVerify */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_selfVerify
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid
);

/* Routine selfVerify */
mig_internal novalue _XselfVerify
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__selfVerify_t __Request;
	typedef __Reply__selfVerify_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__selfVerify_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__selfVerify_t__defined */

	__DeclareRcvRpc(1055, "selfVerify")
	__BeforeRcvRpc(1055, "selfVerify")

#if	defined(__MIG_check__Request__selfVerify_t__defined)
	check_result = __MIG_check__Request__selfVerify_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__selfVerify_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_selfVerify(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1055, "selfVerify")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__cspPassThrough_t__defined)
#define __MIG_check__Request__cspPassThrough_t__defined

mig_internal kern_return_t __MIG_check__Request__cspPassThrough_t(__attribute__((__unused__)) __Request__cspPassThrough_t *In0P)
{

	typedef __Request__cspPassThrough_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->inData.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->inData.size != In0P->inDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__cspPassThrough_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine cspPassThrough */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_cspPassThrough
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	uint32 id,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle hKey,
	Data inData,
	mach_msg_type_number_t inDataCnt,
	Data *outData,
	mach_msg_type_number_t *outDataCnt
);

/* Routine cspPassThrough */
mig_internal novalue _XcspPassThrough
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle hKey;
		mach_msg_type_number_t inDataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__cspPassThrough_t __Request;
	typedef __Reply__cspPassThrough_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__cspPassThrough_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__cspPassThrough_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t outDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1056, "cspPassThrough")
	__BeforeRcvRpc(1056, "cspPassThrough")

#if	defined(__MIG_check__Request__cspPassThrough_t__defined)
	check_result = __MIG_check__Request__cspPassThrough_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__cspPassThrough_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->outData = outDataTemplate;
#else	/* UseStaticTemplates */
	OutP->outData.deallocate =  FALSE;
	OutP->outData.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->outData.pad1 = 0;
	OutP->outData.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->outData.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->outDataCnt = 0;

	RetCode = ucsp_server_cspPassThrough(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, In0P->id, (Data)(In0P->context.address), In0P->context.size, In0P->hKey, (Data)(In0P->inData.address), In0P->inData.size, (Data *)&(OutP->outData.address), &OutP->outDataCnt);
	mig_deallocate((vm_offset_t) In0P->inData.address, In0P->inData.size);
	In0P->inData.address = (void *) 0;
	In0P->inData.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->outData.size = OutP->outDataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1056, "cspPassThrough")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__dlPassThrough_t__defined)
#define __MIG_check__Request__dlPassThrough_t__defined

mig_internal kern_return_t __MIG_check__Request__dlPassThrough_t(__attribute__((__unused__)) __Request__dlPassThrough_t *In0P)
{

	typedef __Request__dlPassThrough_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->inData.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->inData.size != In0P->inDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__dlPassThrough_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine dlPassThrough */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_dlPassThrough
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 ssid,
	uint32 id,
	Data inData,
	mach_msg_type_number_t inDataCnt,
	Data *outData,
	mach_msg_type_number_t *outDataCnt
);

/* Routine dlPassThrough */
mig_internal novalue _XdlPassThrough
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t inDataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__dlPassThrough_t __Request;
	typedef __Reply__dlPassThrough_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__dlPassThrough_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__dlPassThrough_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t outDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1057, "dlPassThrough")
	__BeforeRcvRpc(1057, "dlPassThrough")

#if	defined(__MIG_check__Request__dlPassThrough_t__defined)
	check_result = __MIG_check__Request__dlPassThrough_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__dlPassThrough_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->outData = outDataTemplate;
#else	/* UseStaticTemplates */
	OutP->outData.deallocate =  FALSE;
	OutP->outData.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->outData.pad1 = 0;
	OutP->outData.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->outData.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->outDataCnt = 0;

	RetCode = ucsp_server_dlPassThrough(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->ssid, In0P->id, (Data)(In0P->inData.address), In0P->inData.size, (Data *)&(OutP->outData.address), &OutP->outDataCnt);
	mig_deallocate((vm_offset_t) In0P->inData.address, In0P->inData.size);
	In0P->inData.address = (void *) 0;
	In0P->inData.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->outData.size = OutP->outDataCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1057, "dlPassThrough")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__postNotification_t__defined)
#define __MIG_check__Request__postNotification_t__defined

mig_internal kern_return_t __MIG_check__Request__postNotification_t(__attribute__((__unused__)) __Request__postNotification_t *In0P)
{

	typedef __Request__postNotification_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->data.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->data.size != In0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__postNotification_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine postNotification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_postNotification
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 domain,
	uint32 event,
	Data data,
	mach_msg_type_number_t dataCnt,
	uint32 sequence
);

/* Routine postNotification */
mig_internal novalue _XpostNotification
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 domain;
		uint32 event;
		mach_msg_type_number_t dataCnt;
		uint32 sequence;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__postNotification_t __Request;
	typedef __Reply__postNotification_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__postNotification_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__postNotification_t__defined */

	__DeclareRcvRpc(1069, "postNotification")
	__BeforeRcvRpc(1069, "postNotification")

#if	defined(__MIG_check__Request__postNotification_t__defined)
	check_result = __MIG_check__Request__postNotification_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__postNotification_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_postNotification(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->domain, In0P->event, (Data)(In0P->data.address), In0P->data.size, In0P->sequence);
	mig_deallocate((vm_offset_t) In0P->data.address, In0P->data.size);
	In0P->data.address = (void *) 0;
	In0P->data.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1069, "postNotification")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__extractMasterKey_t__defined)
#define __MIG_check__Request__extractMasterKey_t__defined

mig_internal kern_return_t __MIG_check__Request__extractMasterKey_t(__attribute__((__unused__)) __Request__extractMasterKey_t *In0P)
{

	typedef __Request__extractMasterKey_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 3) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->context.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->accessCredentials.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->aclEntryPrototype.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->context.size != In0P->contextCnt)
		return MIG_TYPE_ERROR;
	if (In0P->accessCredentials.size != In0P->accessCredentialsCnt)
		return MIG_TYPE_ERROR;
	if (In0P->aclEntryPrototype.size != In0P->aclEntryPrototypeCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__extractMasterKey_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine extractMasterKey */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_extractMasterKey
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCDbHandle sourceDb,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
);

/* Routine extractMasterKey */
mig_internal novalue _XextractMasterKey
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCDbHandle sourceDb;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__extractMasterKey_t __Request;
	typedef __Reply__extractMasterKey_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__extractMasterKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__extractMasterKey_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t headerTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1070, "extractMasterKey")
	__BeforeRcvRpc(1070, "extractMasterKey")

#if	defined(__MIG_check__Request__extractMasterKey_t__defined)
	check_result = __MIG_check__Request__extractMasterKey_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__extractMasterKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->header = headerTemplate;
#else	/* UseStaticTemplates */
	OutP->header.deallocate =  FALSE;
	OutP->header.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->header.pad1 = 0;
	OutP->header.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->header.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->headerCnt = 0;

	RetCode = ucsp_server_extractMasterKey(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db, (Data)(In0P->context.address), In0P->context.size, In0P->sourceDb, (Data)(In0P->accessCredentials.address), In0P->accessCredentials.size, (Data)(In0P->aclEntryPrototype.address), In0P->aclEntryPrototype.size, In0P->keyUsage, In0P->keyAttrs, &OutP->key, (Data *)&(OutP->header.address), &OutP->headerCnt);
	mig_deallocate((vm_offset_t) In0P->aclEntryPrototype.address, In0P->aclEntryPrototype.size);
	In0P->aclEntryPrototype.address = (void *) 0;
	In0P->aclEntryPrototype.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->accessCredentials.address, In0P->accessCredentials.size);
	In0P->accessCredentials.address = (void *) 0;
	In0P->accessCredentials.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->context.address, In0P->context.size);
	In0P->context.address = (void *) 0;
	In0P->context.size = (mach_msg_size_t) 0;
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->header.size = OutP->headerCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1070, "extractMasterKey")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__childCheckIn_t__defined)
#define __MIG_check__Request__childCheckIn_t__defined

mig_internal kern_return_t __MIG_check__Request__childCheckIn_t(__attribute__((__unused__)) __Request__childCheckIn_t *In0P)
{

	typedef __Request__childCheckIn_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->servicePort.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->servicePort.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->task_port.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->task_port.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__childCheckIn_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* SimpleRoutine childCheckIn */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_childCheckIn
(
	mach_port_t sport,
	mach_port_t servicePort,
	mach_port_t task_port
);

/* SimpleRoutine childCheckIn */
mig_internal novalue _XchildCheckIn
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t servicePort;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__childCheckIn_t __Request;
	typedef __Reply__childCheckIn_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
#ifdef	__MIG_check__Request__childCheckIn_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__childCheckIn_t__defined */

	__DeclareRcvSimple(1077, "childCheckIn")
	__BeforeRcvSimple(1077, "childCheckIn")

#if	defined(__MIG_check__Request__childCheckIn_t__defined)
	check_result = __MIG_check__Request__childCheckIn_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__childCheckIn_t__defined) */

	OutP->RetCode = ucsp_server_childCheckIn(In0P->Head.msgh_request_port, In0P->servicePort.name, In0P->task_port.name);
	__AfterRcvSimple(1077, "childCheckIn")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__commitDbForSync_t__defined)
#define __MIG_check__Request__commitDbForSync_t__defined

mig_internal kern_return_t __MIG_check__Request__commitDbForSync_t(__attribute__((__unused__)) __Request__commitDbForSync_t *In0P)
{

	typedef __Request__commitDbForSync_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__commitDbForSync_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine commitDbForSync */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_commitDbForSync
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle srcDb,
	IPCDbHandle cloneDb,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt
);

/* Routine commitDbForSync */
mig_internal novalue _XcommitDbForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		IPCDbHandle cloneDb;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__commitDbForSync_t __Request;
	typedef __Reply__commitDbForSync_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__commitDbForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__commitDbForSync_t__defined */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t blobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1078, "commitDbForSync")
	__BeforeRcvRpc(1078, "commitDbForSync")

#if	defined(__MIG_check__Request__commitDbForSync_t__defined)
	check_result = __MIG_check__Request__commitDbForSync_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__commitDbForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->blob = blobTemplate;
#else	/* UseStaticTemplates */
	OutP->blob.deallocate =  FALSE;
	OutP->blob.copy = MACH_MSG_VIRTUAL_COPY;
	OutP->blob.pad1 = 0;
	OutP->blob.type = MACH_MSG_OOL_DESCRIPTOR;
#if defined(KERNEL) && !defined(__LP64__)
	OutP->blob.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	OutP->blobCnt = 0;

	RetCode = ucsp_server_commitDbForSync(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->srcDb, In0P->cloneDb, (Pointer *)&(OutP->blob.address), &OutP->blobCnt);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}
	OutP->blob.size = OutP->blobCnt;


	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1078, "commitDbForSync")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__registerHosting_t__defined)
#define __MIG_check__Request__registerHosting_t__defined

mig_internal kern_return_t __MIG_check__Request__registerHosting_t(__attribute__((__unused__)) __Request__registerHosting_t *In0P)
{

	typedef __Request__registerHosting_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->hostingPort.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->hostingPort.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__registerHosting_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine registerHosting */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_registerHosting
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	mach_port_t hostingPort,
	uint32 flags
);

/* Routine registerHosting */
mig_internal novalue _XregisterHosting
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 flags;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__registerHosting_t __Request;
	typedef __Reply__registerHosting_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__registerHosting_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__registerHosting_t__defined */

	__DeclareRcvRpc(1079, "registerHosting")
	__BeforeRcvRpc(1079, "registerHosting")

#if	defined(__MIG_check__Request__registerHosting_t__defined)
	check_result = __MIG_check__Request__registerHosting_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__registerHosting_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_registerHosting(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->hostingPort.name, In0P->flags);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1079, "registerHosting")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__hostingPort_t__defined)
#define __MIG_check__Request__hostingPort_t__defined

mig_internal kern_return_t __MIG_check__Request__hostingPort_t(__attribute__((__unused__)) __Request__hostingPort_t *In0P)
{

	typedef __Request__hostingPort_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__hostingPort_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine hostingPort */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_hostingPort
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	pid_t hostPid,
	mach_port_t *hostingPort
);

/* Routine hostingPort */
mig_internal novalue _XhostingPort
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		pid_t hostPid;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__hostingPort_t __Request;
	typedef __Reply__hostingPort_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__hostingPort_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__hostingPort_t__defined */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t hostingPortTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1080, "hostingPort")
	__BeforeRcvRpc(1080, "hostingPort")

#if	defined(__MIG_check__Request__hostingPort_t__defined)
	check_result = __MIG_check__Request__hostingPort_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__hostingPort_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->hostingPort = hostingPortTemplate;
#else	/* UseStaticTemplates */
	OutP->hostingPort.disposition = 20;
#if !(defined(KERNEL) && defined(__LP64__))
	OutP->hostingPort.pad1 = 0;
#endif
	OutP->hostingPort.pad2 = 0;
	OutP->hostingPort.type = MACH_MSG_PORT_DESCRIPTOR;
#if defined(KERNEL)
	OutP->hostingPort.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	RetCode = ucsp_server_hostingPort(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->hostPid, &OutP->hostingPort.name);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1080, "hostingPort")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setGuest_t__defined)
#define __MIG_check__Request__setGuest_t__defined

mig_internal kern_return_t __MIG_check__Request__setGuest_t(__attribute__((__unused__)) __Request__setGuest_t *In0P)
{

	typedef __Request__setGuest_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setGuest_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setGuest */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setGuest
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	SecGuestRef guest,
	uint32 flags
);

/* Routine setGuest */
mig_internal novalue _XsetGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32 flags;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setGuest_t __Request;
	typedef __Reply__setGuest_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setGuest_t__defined */

	__DeclareRcvRpc(1081, "setGuest")
	__BeforeRcvRpc(1081, "setGuest")

#if	defined(__MIG_check__Request__setGuest_t__defined)
	check_result = __MIG_check__Request__setGuest_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setGuest(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->guest, In0P->flags);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1081, "setGuest")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__createGuest_t__defined)
#define __MIG_check__Request__createGuest_t__defined

mig_internal kern_return_t __MIG_check__Request__createGuest_t(__attribute__((__unused__)) __Request__createGuest_t *In0P, __attribute__((__unused__)) __Request__createGuest_t **In1PP, __attribute__((__unused__)) __Request__createGuest_t **In2PP)
{

	typedef __Request__createGuest_t __Request;
	__Request *In1P;
	__Request *In2P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1088)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->attributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__createGuest_t__pathCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__createGuest_t__pathCnt(&In0P->pathCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__createGuest_t__pathCnt__defined */
	msgh_size_delta = _WALIGN_(In0P->pathCnt);
#if	__MigTypeCheck
	if ( In0P->pathCnt > 1024 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1088)) < In0P->pathCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1088) + _WALIGN_(In0P->pathCnt)))
		return MIG_BAD_ARGUMENTS;
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 1024);

#if defined(__NDR_convert__int_rep__Request__createGuest_t__cdhashCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__createGuest_t__cdhashCnt(&In1P->cdhashCnt, In1P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__createGuest_t__cdhashCnt__defined */
	msgh_size_delta = _WALIGN_(In1P->cdhashCnt);
#if	__MigTypeCheck
	if ( In1P->cdhashCnt > 64 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1088)) < In1P->cdhashCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 1088) + _WALIGN_(In1P->cdhashCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	*In2PP = In2P = (__Request *) ((pointer_t) In1P + msgh_size_delta - 64);

#if __MigTypeCheck
	if (In0P->attributes.size != In2P->attributesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->path),  1024);
		if (( memchr(In0P->path, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__createGuest_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine createGuest */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_createGuest
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	SecGuestRef host,
	uint32_t status,
	FilePath path,
	HashData cdhash,
	mach_msg_type_number_t cdhashCnt,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	uint32 flags,
	SecGuestRef *guest
);

/* Routine createGuest */
mig_internal novalue _XcreateGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef host;
		uint32_t status;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		mach_msg_type_number_t cdhashCnt;
		char cdhash[64];
		mach_msg_type_number_t attributesCnt;
		uint32 flags;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__createGuest_t __Request;
	typedef __Reply__createGuest_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Request *In1P;
	Request *In2P;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__createGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__createGuest_t__defined */

	__DeclareRcvRpc(1082, "createGuest")
	__BeforeRcvRpc(1082, "createGuest")

#if	defined(__MIG_check__Request__createGuest_t__defined)
	check_result = __MIG_check__Request__createGuest_t((__Request *)In0P, (__Request **)&In1P, (__Request **)&In2P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__createGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_createGuest(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->host, In0P->status, In0P->path, In1P->cdhash, In1P->cdhashCnt, (Data)(In0P->attributes.address), In0P->attributes.size, In2P->flags, &OutP->guest);
	mig_deallocate((vm_offset_t) In0P->attributes.address, In0P->attributes.size);
	In0P->attributes.address = (void *) 0;
	In0P->attributes.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1082, "createGuest")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__setGuestStatus_t__defined)
#define __MIG_check__Request__setGuestStatus_t__defined

mig_internal kern_return_t __MIG_check__Request__setGuestStatus_t(__attribute__((__unused__)) __Request__setGuestStatus_t *In0P)
{

	typedef __Request__setGuestStatus_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->attributes.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->attributes.size != In0P->attributesCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__setGuestStatus_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setGuestStatus */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_setGuestStatus
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	SecGuestRef guest,
	uint32_t status,
	Data attributes,
	mach_msg_type_number_t attributesCnt
);

/* Routine setGuestStatus */
mig_internal novalue _XsetGuestStatus
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32_t status;
		mach_msg_type_number_t attributesCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__setGuestStatus_t __Request;
	typedef __Reply__setGuestStatus_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__setGuestStatus_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__setGuestStatus_t__defined */

	__DeclareRcvRpc(1083, "setGuestStatus")
	__BeforeRcvRpc(1083, "setGuestStatus")

#if	defined(__MIG_check__Request__setGuestStatus_t__defined)
	check_result = __MIG_check__Request__setGuestStatus_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__setGuestStatus_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_setGuestStatus(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->guest, In0P->status, (Data)(In0P->attributes.address), In0P->attributes.size);
	mig_deallocate((vm_offset_t) In0P->attributes.address, In0P->attributes.size);
	In0P->attributes.address = (void *) 0;
	In0P->attributes.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1083, "setGuestStatus")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__removeGuest_t__defined)
#define __MIG_check__Request__removeGuest_t__defined

mig_internal kern_return_t __MIG_check__Request__removeGuest_t(__attribute__((__unused__)) __Request__removeGuest_t *In0P)
{

	typedef __Request__removeGuest_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__removeGuest_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine removeGuest */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_removeGuest
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	SecGuestRef host,
	SecGuestRef guest
);

/* Routine removeGuest */
mig_internal novalue _XremoveGuest
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef host;
		SecGuestRef guest;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__removeGuest_t __Request;
	typedef __Reply__removeGuest_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__removeGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__removeGuest_t__defined */

	__DeclareRcvRpc(1084, "removeGuest")
	__BeforeRcvRpc(1084, "removeGuest")

#if	defined(__MIG_check__Request__removeGuest_t__defined)
	check_result = __MIG_check__Request__removeGuest_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__removeGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_removeGuest(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->host, In0P->guest);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1084, "removeGuest")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__helpCheckLoad_t__defined)
#define __MIG_check__Request__helpCheckLoad_t__defined

mig_internal kern_return_t __MIG_check__Request__helpCheckLoad_t(__attribute__((__unused__)) __Request__helpCheckLoad_t *In0P, __attribute__((__unused__)) __Request__helpCheckLoad_t **In1PP)
{

	typedef __Request__helpCheckLoad_t __Request;
	__Request *In1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 1024)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__helpCheckLoad_t__pathCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__helpCheckLoad_t__pathCnt(&In0P->pathCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__helpCheckLoad_t__pathCnt__defined */
	msgh_size_delta = _WALIGN_(In0P->pathCnt);
#if	__MigTypeCheck
	if ( In0P->pathCnt > 1024 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 1024)) < In0P->pathCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 1024) + _WALIGN_(In0P->pathCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 1024);

#if __MigTypeCheck
	{
		char * msg_limit = ((char *) In0P) + In0P->Head.msgh_size;
		size_t memchr_limit;

		memchr_limit = min((msg_limit - In0P->path),  1024);
		if (( memchr(In0P->path, '\0', memchr_limit) == NULL ))
			return MIG_BAD_ARGUMENTS; // string length exceeds buffer length!
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__helpCheckLoad_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine helpCheckLoad */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_helpCheckLoad
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	FilePath path,
	uint32_t addType
);

/* Routine helpCheckLoad */
mig_internal novalue _XhelpCheckLoad
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		uint32_t addType;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__helpCheckLoad_t __Request;
	typedef __Reply__helpCheckLoad_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Request *In1P;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__helpCheckLoad_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__helpCheckLoad_t__defined */

	__DeclareRcvRpc(1085, "helpCheckLoad")
	__BeforeRcvRpc(1085, "helpCheckLoad")

#if	defined(__MIG_check__Request__helpCheckLoad_t__defined)
	check_result = __MIG_check__Request__helpCheckLoad_t((__Request *)In0P, (__Request **)&In1P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__helpCheckLoad_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_helpCheckLoad(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->path, In1P->addType);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1085, "helpCheckLoad")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__recodeDbForSync_t__defined)
#define __MIG_check__Request__recodeDbForSync_t__defined

mig_internal kern_return_t __MIG_check__Request__recodeDbForSync_t(__attribute__((__unused__)) __Request__recodeDbForSync_t *In0P)
{

	typedef __Request__recodeDbForSync_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__recodeDbForSync_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeDbForSync */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_recodeDbForSync
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle dbToClone,
	IPCDbHandle srcDb,
	IPCDbHandle *newDb
);

/* Routine recodeDbForSync */
mig_internal novalue _XrecodeDbForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle dbToClone;
		IPCDbHandle srcDb;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__recodeDbForSync_t __Request;
	typedef __Reply__recodeDbForSync_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__recodeDbForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__recodeDbForSync_t__defined */

	__DeclareRcvRpc(1086, "recodeDbForSync")
	__BeforeRcvRpc(1086, "recodeDbForSync")

#if	defined(__MIG_check__Request__recodeDbForSync_t__defined)
	check_result = __MIG_check__Request__recodeDbForSync_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__recodeDbForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_recodeDbForSync(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->dbToClone, In0P->srcDb, &OutP->newDb);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1086, "recodeDbForSync")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__authenticateDbsForSync_t__defined)
#define __MIG_check__Request__authenticateDbsForSync_t__defined

mig_internal kern_return_t __MIG_check__Request__authenticateDbsForSync_t(__attribute__((__unused__)) __Request__authenticateDbsForSync_t *In0P)
{

	typedef __Request__authenticateDbsForSync_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->ipcDbHandleArray.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->agentData.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->ipcDbHandleArray.size != In0P->ipcDbHandleArrayCnt)
		return MIG_TYPE_ERROR;
	if (In0P->agentData.size != In0P->agentDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__authenticateDbsForSync_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine authenticateDbsForSync */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_authenticateDbsForSync
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data ipcDbHandleArray,
	mach_msg_type_number_t ipcDbHandleArrayCnt,
	Data agentData,
	mach_msg_type_number_t agentDataCnt,
	IPCDbHandle *newDb
);

/* Routine authenticateDbsForSync */
mig_internal novalue _XauthenticateDbsForSync
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ipcDbHandleArray;
		mach_msg_ool_descriptor_t agentData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ipcDbHandleArrayCnt;
		mach_msg_type_number_t agentDataCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__authenticateDbsForSync_t __Request;
	typedef __Reply__authenticateDbsForSync_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__authenticateDbsForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__authenticateDbsForSync_t__defined */

	__DeclareRcvRpc(1087, "authenticateDbsForSync")
	__BeforeRcvRpc(1087, "authenticateDbsForSync")

#if	defined(__MIG_check__Request__authenticateDbsForSync_t__defined)
	check_result = __MIG_check__Request__authenticateDbsForSync_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__authenticateDbsForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_authenticateDbsForSync(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->ipcDbHandleArray.address), In0P->ipcDbHandleArray.size, (Data)(In0P->agentData.address), In0P->agentData.size, &OutP->newDb);
	mig_deallocate((vm_offset_t) In0P->agentData.address, In0P->agentData.size);
	In0P->agentData.address = (void *) 0;
	In0P->agentData.size = (mach_msg_size_t) 0;
	mig_deallocate((vm_offset_t) In0P->ipcDbHandleArray.address, In0P->ipcDbHandleArray.size);
	In0P->ipcDbHandleArray.address = (void *) 0;
	In0P->ipcDbHandleArray.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1087, "authenticateDbsForSync")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__verifyPrivileged_t__defined)
#define __MIG_check__Request__verifyPrivileged_t__defined

mig_internal kern_return_t __MIG_check__Request__verifyPrivileged_t(__attribute__((__unused__)) __Request__verifyPrivileged_t *In0P)
{

	typedef __Request__verifyPrivileged_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__verifyPrivileged_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyPrivileged */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_verifyPrivileged
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode
);

/* Routine verifyPrivileged */
mig_internal novalue _XverifyPrivileged
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__verifyPrivileged_t __Request;
	typedef __Reply__verifyPrivileged_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__verifyPrivileged_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__verifyPrivileged_t__defined */

	__DeclareRcvRpc(1088, "verifyPrivileged")
	__BeforeRcvRpc(1088, "verifyPrivileged")

#if	defined(__MIG_check__Request__verifyPrivileged_t__defined)
	check_result = __MIG_check__Request__verifyPrivileged_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__verifyPrivileged_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_verifyPrivileged(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1088, "verifyPrivileged")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__verifyPrivileged2_t__defined)
#define __MIG_check__Request__verifyPrivileged2_t__defined

mig_internal kern_return_t __MIG_check__Request__verifyPrivileged2_t(__attribute__((__unused__)) __Request__verifyPrivileged2_t *In0P)
{

	typedef __Request__verifyPrivileged2_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__verifyPrivileged2_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyPrivileged2 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_verifyPrivileged2
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	mach_port_t *originPort
);

/* Routine verifyPrivileged2 */
mig_internal novalue _XverifyPrivileged2
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__verifyPrivileged2_t __Request;
	typedef __Reply__verifyPrivileged2_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__verifyPrivileged2_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__verifyPrivileged2_t__defined */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t originPortTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	kern_return_t RetCode;
	__DeclareRcvRpc(1089, "verifyPrivileged2")
	__BeforeRcvRpc(1089, "verifyPrivileged2")

#if	defined(__MIG_check__Request__verifyPrivileged2_t__defined)
	check_result = __MIG_check__Request__verifyPrivileged2_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__verifyPrivileged2_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
#if	UseStaticTemplates
	OutP->originPort = originPortTemplate;
#else	/* UseStaticTemplates */
	OutP->originPort.disposition = 20;
#if !(defined(KERNEL) && defined(__LP64__))
	OutP->originPort.pad1 = 0;
#endif
	OutP->originPort.pad2 = 0;
	OutP->originPort.type = MACH_MSG_PORT_DESCRIPTOR;
#if defined(KERNEL)
	OutP->originPort.pad_end = 0;
#endif
#endif	/* UseStaticTemplates */


	RetCode = ucsp_server_verifyPrivileged2(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, &OutP->originPort.name);
	if (RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	OutP->msgh_body.msgh_descriptor_count = 1;
	__AfterRcvRpc(1089, "verifyPrivileged2")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__stashDb_t__defined)
#define __MIG_check__Request__stashDb_t__defined

mig_internal kern_return_t __MIG_check__Request__stashDb_t(__attribute__((__unused__)) __Request__stashDb_t *In0P)
{

	typedef __Request__stashDb_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__stashDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine stashDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_stashDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db
);

/* Routine stashDb */
mig_internal novalue _XstashDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__stashDb_t __Request;
	typedef __Reply__stashDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__stashDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__stashDb_t__defined */

	__DeclareRcvRpc(1090, "stashDb")
	__BeforeRcvRpc(1090, "stashDb")

#if	defined(__MIG_check__Request__stashDb_t__defined)
	check_result = __MIG_check__Request__stashDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__stashDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_stashDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1090, "stashDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__stashDbCheck_t__defined)
#define __MIG_check__Request__stashDbCheck_t__defined

mig_internal kern_return_t __MIG_check__Request__stashDbCheck_t(__attribute__((__unused__)) __Request__stashDbCheck_t *In0P)
{

	typedef __Request__stashDbCheck_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__stashDbCheck_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine stashDbCheck */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_stashDbCheck
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db
);

/* Routine stashDbCheck */
mig_internal novalue _XstashDbCheck
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__stashDbCheck_t __Request;
	typedef __Reply__stashDbCheck_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__stashDbCheck_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__stashDbCheck_t__defined */

	__DeclareRcvRpc(1091, "stashDbCheck")
	__BeforeRcvRpc(1091, "stashDbCheck")

#if	defined(__MIG_check__Request__stashDbCheck_t__defined)
	check_result = __MIG_check__Request__stashDbCheck_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__stashDbCheck_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_stashDbCheck(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1091, "stashDbCheck")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__verifyKeyStorePassphrase_t__defined)
#define __MIG_check__Request__verifyKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Request__verifyKeyStorePassphrase_t(__attribute__((__unused__)) __Request__verifyKeyStorePassphrase_t *In0P)
{

	typedef __Request__verifyKeyStorePassphrase_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__verifyKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyKeyStorePassphrase */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_verifyKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32_t retries
);

/* Routine verifyKeyStorePassphrase */
mig_internal novalue _XverifyKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t retries;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__verifyKeyStorePassphrase_t __Request;
	typedef __Reply__verifyKeyStorePassphrase_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__verifyKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__verifyKeyStorePassphrase_t__defined */

	__DeclareRcvRpc(1092, "verifyKeyStorePassphrase")
	__BeforeRcvRpc(1092, "verifyKeyStorePassphrase")

#if	defined(__MIG_check__Request__verifyKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Request__verifyKeyStorePassphrase_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__verifyKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_verifyKeyStorePassphrase(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->retries);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1092, "verifyKeyStorePassphrase")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__resetKeyStorePassphrase_t__defined)
#define __MIG_check__Request__resetKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Request__resetKeyStorePassphrase_t(__attribute__((__unused__)) __Request__resetKeyStorePassphrase_t *In0P)
{

	typedef __Request__resetKeyStorePassphrase_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->passPhrase.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->passPhrase.size != In0P->passPhraseCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__resetKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine resetKeyStorePassphrase */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_resetKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	Data passPhrase,
	mach_msg_type_number_t passPhraseCnt
);

/* Routine resetKeyStorePassphrase */
mig_internal novalue _XresetKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t passPhraseCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__resetKeyStorePassphrase_t __Request;
	typedef __Reply__resetKeyStorePassphrase_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__resetKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__resetKeyStorePassphrase_t__defined */

	__DeclareRcvRpc(1093, "resetKeyStorePassphrase")
	__BeforeRcvRpc(1093, "resetKeyStorePassphrase")

#if	defined(__MIG_check__Request__resetKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Request__resetKeyStorePassphrase_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__resetKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_resetKeyStorePassphrase(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, (Data)(In0P->passPhrase.address), In0P->passPhrase.size);
	mig_deallocate((vm_offset_t) In0P->passPhrase.address, In0P->passPhrase.size);
	In0P->passPhrase.address = (void *) 0;
	In0P->passPhrase.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1093, "resetKeyStorePassphrase")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__changeKeyStorePassphrase_t__defined)
#define __MIG_check__Request__changeKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Request__changeKeyStorePassphrase_t(__attribute__((__unused__)) __Request__changeKeyStorePassphrase_t *In0P)
{

	typedef __Request__changeKeyStorePassphrase_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__changeKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changeKeyStorePassphrase */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_changeKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode
);

/* Routine changeKeyStorePassphrase */
mig_internal novalue _XchangeKeyStorePassphrase
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__changeKeyStorePassphrase_t __Request;
	typedef __Reply__changeKeyStorePassphrase_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__changeKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__changeKeyStorePassphrase_t__defined */

	__DeclareRcvRpc(1094, "changeKeyStorePassphrase")
	__BeforeRcvRpc(1094, "changeKeyStorePassphrase")

#if	defined(__MIG_check__Request__changeKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Request__changeKeyStorePassphrase_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__changeKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_changeKeyStorePassphrase(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1094, "changeKeyStorePassphrase")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__recodeDbToVersion_t__defined)
#define __MIG_check__Request__recodeDbToVersion_t__defined

mig_internal kern_return_t __MIG_check__Request__recodeDbToVersion_t(__attribute__((__unused__)) __Request__recodeDbToVersion_t *In0P)
{

	typedef __Request__recodeDbToVersion_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__recodeDbToVersion_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeDbToVersion */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_recodeDbToVersion
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32 newVersion,
	IPCDbHandle srcDb,
	IPCDbHandle *newDb
);

/* Routine recodeDbToVersion */
mig_internal novalue _XrecodeDbToVersion
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 newVersion;
		IPCDbHandle srcDb;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__recodeDbToVersion_t __Request;
	typedef __Reply__recodeDbToVersion_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__recodeDbToVersion_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__recodeDbToVersion_t__defined */

	__DeclareRcvRpc(1095, "recodeDbToVersion")
	__BeforeRcvRpc(1095, "recodeDbToVersion")

#if	defined(__MIG_check__Request__recodeDbToVersion_t__defined)
	check_result = __MIG_check__Request__recodeDbToVersion_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__recodeDbToVersion_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_recodeDbToVersion(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->newVersion, In0P->srcDb, &OutP->newDb);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1095, "recodeDbToVersion")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__cloneDb_t__defined)
#define __MIG_check__Request__cloneDb_t__defined

mig_internal kern_return_t __MIG_check__Request__cloneDb_t(__attribute__((__unused__)) __Request__cloneDb_t *In0P)
{

	typedef __Request__cloneDb_t __Request;
#if	__MigTypeCheck
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 1) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->ident.type != MACH_MSG_OOL_DESCRIPTOR)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (In0P->ident.size != In0P->identCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__cloneDb_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine cloneDb */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_cloneDb
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle srcDb,
	Data ident,
	mach_msg_type_number_t identCnt,
	IPCDbHandle *newDb
);

/* Routine cloneDb */
mig_internal novalue _XcloneDb
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		mach_msg_type_number_t identCnt;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__cloneDb_t __Request;
	typedef __Reply__cloneDb_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__cloneDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__cloneDb_t__defined */

	__DeclareRcvRpc(1096, "cloneDb")
	__BeforeRcvRpc(1096, "cloneDb")

#if	defined(__MIG_check__Request__cloneDb_t__defined)
	check_result = __MIG_check__Request__cloneDb_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__cloneDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_cloneDb(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->srcDb, (Data)(In0P->ident.address), In0P->ident.size, &OutP->newDb);
	mig_deallocate((vm_offset_t) In0P->ident.address, In0P->ident.size);
	In0P->ident.address = (void *) 0;
	In0P->ident.size = (mach_msg_size_t) 0;
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1096, "cloneDb")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__recodeFinished_t__defined)
#define __MIG_check__Request__recodeFinished_t__defined

mig_internal kern_return_t __MIG_check__Request__recodeFinished_t(__attribute__((__unused__)) __Request__recodeFinished_t *In0P)
{

	typedef __Request__recodeFinished_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__recodeFinished_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeFinished */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_recodeFinished
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	IPCDbHandle db
);

/* Routine recodeFinished */
mig_internal novalue _XrecodeFinished
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__recodeFinished_t __Request;
	typedef __Reply__recodeFinished_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__recodeFinished_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__recodeFinished_t__defined */

	__DeclareRcvRpc(1097, "recodeFinished")
	__BeforeRcvRpc(1097, "recodeFinished")

#if	defined(__MIG_check__Request__recodeFinished_t__defined)
	check_result = __MIG_check__Request__recodeFinished_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__recodeFinished_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_recodeFinished(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, In0P->db);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1097, "recodeFinished")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__ucsp_subsystem__
#if !defined(__MIG_check__Request__getUserPromptAttempts_t__defined)
#define __MIG_check__Request__getUserPromptAttempts_t__defined

mig_internal kern_return_t __MIG_check__Request__getUserPromptAttempts_t(__attribute__((__unused__)) __Request__getUserPromptAttempts_t *In0P)
{

	typedef __Request__getUserPromptAttempts_t __Request;
#if	__MigTypeCheck
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->Head.msgh_size != (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__getUserPromptAttempts_t__defined) */
#endif /* __MIG_check__Request__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getUserPromptAttempts */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t ucsp_server_getUserPromptAttempts
(
	mach_port_t sport,
	mach_port_t rport,
	audit_token_t sourceAudit,
	CSSM_RETURN *rcode,
	uint32_t *attempts
);

/* Routine getUserPromptAttempts */
mig_internal novalue _XgetUserPromptAttempts
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		mach_msg_max_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	typedef __Request__getUserPromptAttempts_t __Request;
	typedef __Reply__getUserPromptAttempts_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */
#ifdef	__MIG_check__Request__getUserPromptAttempts_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__getUserPromptAttempts_t__defined */

	__DeclareRcvRpc(1098, "getUserPromptAttempts")
	__BeforeRcvRpc(1098, "getUserPromptAttempts")

#if	defined(__MIG_check__Request__getUserPromptAttempts_t__defined)
	check_result = __MIG_check__Request__getUserPromptAttempts_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__getUserPromptAttempts_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)In0P +
		round_msg(In0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ MIG_RETURN_ERROR(In0P, MIG_TRAILER_ERROR); }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(audit_token_t))
		{ MIG_RETURN_ERROR(OutP, MIG_TRAILER_ERROR); }
	trailer_size -= (mach_msg_size_t)sizeof(audit_token_t);
#endif	/* __MigTypeCheck */
	OutP->RetCode = ucsp_server_getUserPromptAttempts(In0P->Head.msgh_request_port, In0P->Head.msgh_reply_port, TrailerP->msgh_audit, &OutP->rcode, &OutP->attempts);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
	__AfterRcvRpc(1098, "getUserPromptAttempts")
}


#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
boolean_t ucsp_server(
		mach_msg_header_t *InHeadP,
		mach_msg_header_t *OutHeadP);

#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
mig_routine_t ucsp_server_routine(
		mach_msg_header_t *InHeadP);


/* Description of this subsystem, for use in direct RPC */
const struct ucsp_server_ucsp_subsystem {
	mig_server_routine_t 	server;	/* Server routine */
	mach_msg_id_t	start;	/* Min routine number */
	mach_msg_id_t	end;	/* Max routine number + 1 */
	unsigned int	maxsize;	/* Max msg size */
	vm_address_t	reserved;	/* Reserved */
	struct routine_descriptor	/*Array of routine descriptors */
		routine[99];
} ucsp_server_ucsp_subsystem = {
	ucsp_server_routine,
	1000,
	1099,
	(mach_msg_size_t)sizeof(union __ReplyUnion__ucsp_server_ucsp_subsystem),
	(vm_address_t)0,
	{
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xsetup, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setup_t)},
		{0, 0, 0, 0, 0, 0},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetupThread, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setupThread_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XauthenticateDb, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__authenticateDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XreleaseDb, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__releaseDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetDbName, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getDbName_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetDbName, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setDbName_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XopenToken, 16, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__openToken_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XfindFirst, 24, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__findFirst_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XfindNext, 21, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__findNext_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XfindRecordHandle, 20, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__findRecordHandle_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XinsertRecord, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__insertRecord_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XdeleteRecord, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__deleteRecord_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XmodifyRecord, 20, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__modifyRecord_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XreleaseSearch, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__releaseSearch_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XreleaseRecord, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__releaseRecord_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XcreateDb, 20, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__createDb_t)},
		{0, 0, 0, 0, 0, 0},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XdecodeDb, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__decodeDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XencodeDb, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__encodeDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetDbParameters, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setDbParameters_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetDbParameters, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getDbParameters_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XchangePassphrase, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__changePassphrase_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XlockAll, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__lockAll_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XunlockDb, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__unlockDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XunlockDbWithPassphrase, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__unlockDbWithPassphrase_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XisLocked, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__isLocked_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XencodeKey, 17, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__encodeKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XdecodeKey, 17, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__decodeKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XrecodeKey, 16, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__recodeKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XreleaseKey, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__releaseKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XqueryKeySizeInBits, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__queryKeySizeInBits_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetOutputSize, 17, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getOutputSize_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetKeyDigest, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getKeyDigest_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgenerateSignature, 19, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__generateSignature_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XverifySignature, 19, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__verifySignature_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgenerateMac, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__generateMac_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XverifyMac, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__verifyMac_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xencrypt, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__encrypt_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xdecrypt, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__decrypt_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgenerateKey, 23, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__generateKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgenerateKeyPair, 28, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__generateKeyPair_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XwrapKey, 21, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__wrapKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XunwrapKey, 29, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__unwrapKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XderiveKey, 28, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__deriveKey_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgenerateRandom, 16, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__generateRandom_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetOwner, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getOwner_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetOwner, 17, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setOwner_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetAcl, 18, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getAcl_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XchangeAcl, 19, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__changeAcl_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xlogin, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__login_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xlogout, 11, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__logout_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetStatistics, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getStatistics_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetTime, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getTime_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetCounter, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getCounter_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XselfVerify, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__selfVerify_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XcspPassThrough, 20, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__cspPassThrough_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XdlPassThrough, 17, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__dlPassThrough_t)},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XpostNotification, 16, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__postNotification_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XextractMasterKey, 24, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__extractMasterKey_t)},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XchildCheckIn, 3, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__childCheckIn_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XcommitDbForSync, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__commitDbForSync_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XregisterHosting, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__registerHosting_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XhostingPort, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__hostingPort_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetGuest, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setGuest_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XcreateGuest, 20, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__createGuest_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XsetGuestStatus, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__setGuestStatus_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XremoveGuest, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__removeGuest_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XhelpCheckLoad, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__helpCheckLoad_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XrecodeDbForSync, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__recodeDbForSync_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XauthenticateDbsForSync, 16, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__authenticateDbsForSync_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XverifyPrivileged, 11, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__verifyPrivileged_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XverifyPrivileged2, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__verifyPrivileged2_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XstashDb, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__stashDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XstashDbCheck, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__stashDbCheck_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XverifyKeyStorePassphrase, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__verifyKeyStorePassphrase_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XresetKeyStorePassphrase, 13, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__resetKeyStorePassphrase_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XchangeKeyStorePassphrase, 11, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__changeKeyStorePassphrase_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XrecodeDbToVersion, 14, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__recodeDbToVersion_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XcloneDb, 15, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__cloneDb_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XrecodeFinished, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__recodeFinished_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _XgetUserPromptAttempts, 12, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__getUserPromptAttempts_t)},
	}
};

mig_external boolean_t ucsp_server
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	register mig_routine_t routine;

	OutHeadP->msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REPLY(InHeadP->msgh_bits), 0);
	OutHeadP->msgh_remote_port = InHeadP->msgh_reply_port;
	/* Minimal size: routine() will update it if different */
	OutHeadP->msgh_size = (mach_msg_size_t)sizeof(mig_reply_error_t);
	OutHeadP->msgh_local_port = MACH_PORT_NULL;
	OutHeadP->msgh_id = InHeadP->msgh_id + 100;
	OutHeadP->msgh_reserved = 0;

	if ((InHeadP->msgh_id > 1098) || (InHeadP->msgh_id < 1000) ||
	    ((routine = ucsp_server_ucsp_subsystem.routine[InHeadP->msgh_id - 1000].stub_routine) == 0)) {
		((mig_reply_error_t *)OutHeadP)->NDR = NDR_record;
		((mig_reply_error_t *)OutHeadP)->RetCode = MIG_BAD_ID;
		return FALSE;
	}
	(*routine) (InHeadP, OutHeadP);
	return TRUE;
}

mig_external mig_routine_t ucsp_server_routine
	(mach_msg_header_t *InHeadP)
{
	register int msgh_id;

	msgh_id = InHeadP->msgh_id - 1000;

	if ((msgh_id > 98) || (msgh_id < 0))
		return 0;

	return ucsp_server_ucsp_subsystem.routine[msgh_id].stub_routine;
}
